{"ast":null,"code":"import _objectSpread from \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport find from 'lodash/find';\nimport { matchPath } from 'react-router-dom';\nimport pathToRegexp from 'path-to-regexp';\nimport { stringify } from './urlHelpers';\n\nconst findRouteByName = (nameToFind, routes) => find(routes, route => route.name === nameToFind);\n/**\n * E.g. ```const toListingPath = toPathByRouteName('ListingPage', routes);```\n * Then we can generate listing paths with given params (```toListingPath({ id: uuidX })```)\n */\n\n\nconst toPathByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n\n  if (!route) {\n    throw new Error(\"Path \\\"\".concat(nameToFind, \"\\\" was not found.\"));\n  }\n\n  return pathToRegexp.compile(route.path);\n};\n/**\n * Shorthand for single path call. (```pathByRouteName('ListingPage', routes, { id: uuidX });```)\n */\n\n\nexport const pathByRouteName = (nameToFind, routes, params = {}) => {\n  const hasEmptySlug = params && params.hasOwnProperty('slug') && params.slug === '';\n  const pathParams = hasEmptySlug ? _objectSpread({}, params, {\n    slug: 'no-slug'\n  }) : params;\n  return toPathByRouteName(nameToFind, routes)(pathParams);\n};\n/**\n * Find the matching routes and their params for the given pathname\n *\n * @param {String} pathname - Full URL path from root with possible\n * search params and hash included\n *\n * @return {Array<{ route, params }>} - All matches as { route, params } objects if matches has\n * exact flag set to false. If not, an array containing just the first matched exact route is returned.\n */\n\nexport const matchPathname = (pathname, routeConfiguration) => {\n  const matchedRoutes = routeConfiguration.reduce((matches, route) => {\n    const path = route.path,\n          _route$exact = route.exact,\n          exact = _route$exact === void 0 ? true : _route$exact;\n    const match = matchPath(pathname, {\n      path,\n      exact\n    });\n\n    if (match) {\n      matches.push({\n        route,\n        params: match.params || {}\n      });\n    }\n\n    return matches;\n  }, []);\n  const matchedExactRoute = matchedRoutes.find(r => {\n    return r.exact === true || r.exact == null;\n  }); // We return matched 'exact' path route only if such exists\n  // and all matches if no exact flag exists.\n\n  return matchedExactRoute ? [matchedExactRoute] : matchedRoutes;\n};\n/**\n * ResourceLocatorString is used to direct webapp to correct page.\n * In contrast to Universal Resource Locator (URL), this doesn't contain protocol, host, or port.\n */\n\nexport const createResourceLocatorString = (routeName, routes, pathParams = {}, searchParams = {}, hash = '') => {\n  const searchQuery = stringify(searchParams);\n  const includeSearchQuery = searchQuery.length > 0 ? \"?\".concat(searchQuery) : '';\n  const path = pathByRouteName(routeName, routes, pathParams);\n  return \"\".concat(path).concat(includeSearchQuery).concat(hash);\n};\n/**\n * Find component related to route name\n * E.g. `const PageComponent = findComponentByRouteName('CheckoutPage', routes);`\n * Then we can call static methods of given component:\n * `dispatch(PageComponent.setInitialValues({ listing, bookingDates }));`\n *\n * @param {String} nameToFind - Route name\n * @param {Array<{ route }>} routes - Route configuration as flat array.\n *\n * @return {Route} - Route that matches the given route name.\n */\n\nexport const findRouteByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n\n  if (!route) {\n    throw new Error(\"Component \\\"\".concat(nameToFind, \"\\\" was not found.\"));\n  }\n\n  return route;\n};\n/**\n * Get the canonical URL from the given location\n *\n * @param {Array<{ route }>} routes - Route configuration as flat array\n * @param {Object} location - location object from React Router\n *\n * @return {String} Canonical URL of the given location\n *\n */\n\nexport const canonicalRoutePath = (routes, location, pathOnly = false) => {\n  const pathname = location.pathname,\n        search = location.search,\n        hash = location.hash;\n  const matches = matchPathname(pathname, routes);\n  const isListingRoute = matches.length === 1 && matches[0].route.name === 'ListingPage';\n\n  if (isListingRoute) {\n    // Remove the dynamic slug from the listing page canonical URL\n    // Remove possible trailing slash\n    const cleanedPathName = pathname.replace(/\\/$/, '');\n    const parts = cleanedPathName.split('/');\n\n    if (parts.length !== 4) {\n      throw new Error('Expected ListingPage route to have 4 parts');\n    }\n\n    const canonicalListingPathname = \"/\".concat(parts[1], \"/\").concat(parts[3]);\n    return pathOnly ? canonicalListingPathname : \"\".concat(canonicalListingPathname).concat(search).concat(hash);\n  }\n\n  return pathOnly ? pathname : \"\".concat(pathname).concat(search).concat(hash);\n};","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/util/routes.js"],"names":["find","matchPath","pathToRegexp","stringify","findRouteByName","nameToFind","routes","route","name","toPathByRouteName","Error","compile","path","pathByRouteName","params","hasEmptySlug","hasOwnProperty","slug","pathParams","matchPathname","pathname","routeConfiguration","matchedRoutes","reduce","matches","exact","match","push","matchedExactRoute","r","createResourceLocatorString","routeName","searchParams","hash","searchQuery","includeSearchQuery","length","findRouteByRouteName","canonicalRoutePath","location","pathOnly","search","isListingRoute","cleanedPathName","replace","parts","split","canonicalListingPathname"],"mappings":"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","sourcesContent":["import find from 'lodash/find';\nimport { matchPath } from 'react-router-dom';\nimport pathToRegexp from 'path-to-regexp';\nimport { stringify } from './urlHelpers';\n\nconst findRouteByName = (nameToFind, routes) => find(routes, route => route.name === nameToFind);\n\n/**\n * E.g. ```const toListingPath = toPathByRouteName('ListingPage', routes);```\n * Then we can generate listing paths with given params (```toListingPath({ id: uuidX })```)\n */\nconst toPathByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n  if (!route) {\n    throw new Error(`Path \"${nameToFind}\" was not found.`);\n  }\n  return pathToRegexp.compile(route.path);\n};\n\n/**\n * Shorthand for single path call. (```pathByRouteName('ListingPage', routes, { id: uuidX });```)\n */\nexport const pathByRouteName = (nameToFind, routes, params = {}) => {\n  const hasEmptySlug = params && params.hasOwnProperty('slug') && params.slug === '';\n  const pathParams = hasEmptySlug ? { ...params, slug: 'no-slug' } : params;\n  return toPathByRouteName(nameToFind, routes)(pathParams);\n};\n\n/**\n * Find the matching routes and their params for the given pathname\n *\n * @param {String} pathname - Full URL path from root with possible\n * search params and hash included\n *\n * @return {Array<{ route, params }>} - All matches as { route, params } objects if matches has\n * exact flag set to false. If not, an array containing just the first matched exact route is returned.\n */\nexport const matchPathname = (pathname, routeConfiguration) => {\n  const matchedRoutes = routeConfiguration.reduce((matches, route) => {\n    const { path, exact = true } = route;\n    const match = matchPath(pathname, { path, exact });\n    if (match) {\n      matches.push({\n        route,\n        params: match.params || {},\n      });\n    }\n    return matches;\n  }, []);\n\n  const matchedExactRoute = matchedRoutes.find(r => {\n    return r.exact === true || r.exact == null;\n  });\n\n  // We return matched 'exact' path route only if such exists\n  // and all matches if no exact flag exists.\n  return matchedExactRoute ? [matchedExactRoute] : matchedRoutes;\n};\n\n/**\n * ResourceLocatorString is used to direct webapp to correct page.\n * In contrast to Universal Resource Locator (URL), this doesn't contain protocol, host, or port.\n */\nexport const createResourceLocatorString = (\n  routeName,\n  routes,\n  pathParams = {},\n  searchParams = {},\n  hash = ''\n) => {\n  const searchQuery = stringify(searchParams);\n  const includeSearchQuery = searchQuery.length > 0 ? `?${searchQuery}` : '';\n  const path = pathByRouteName(routeName, routes, pathParams);\n  return `${path}${includeSearchQuery}${hash}`;\n};\n\n/**\n * Find component related to route name\n * E.g. `const PageComponent = findComponentByRouteName('CheckoutPage', routes);`\n * Then we can call static methods of given component:\n * `dispatch(PageComponent.setInitialValues({ listing, bookingDates }));`\n *\n * @param {String} nameToFind - Route name\n * @param {Array<{ route }>} routes - Route configuration as flat array.\n *\n * @return {Route} - Route that matches the given route name.\n */\nexport const findRouteByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n  if (!route) {\n    throw new Error(`Component \"${nameToFind}\" was not found.`);\n  }\n  return route;\n};\n\n/**\n * Get the canonical URL from the given location\n *\n * @param {Array<{ route }>} routes - Route configuration as flat array\n * @param {Object} location - location object from React Router\n *\n * @return {String} Canonical URL of the given location\n *\n */\nexport const canonicalRoutePath = (routes, location, pathOnly = false) => {\n  const { pathname, search, hash } = location;\n\n  const matches = matchPathname(pathname, routes);\n  const isListingRoute = matches.length === 1 && matches[0].route.name === 'ListingPage';\n\n  if (isListingRoute) {\n    // Remove the dynamic slug from the listing page canonical URL\n\n    // Remove possible trailing slash\n    const cleanedPathName = pathname.replace(/\\/$/, '');\n    const parts = cleanedPathName.split('/');\n\n    if (parts.length !== 4) {\n      throw new Error('Expected ListingPage route to have 4 parts');\n    }\n    const canonicalListingPathname = `/${parts[1]}/${parts[3]}`;\n    return pathOnly ? canonicalListingPathname : `${canonicalListingPathname}${search}${hash}`;\n  }\n\n  return pathOnly ? pathname : `${pathname}${search}${hash}`;\n};\n"]},"metadata":{},"sourceType":"module"}