{"ast":null,"code":"import _objectSpread from \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/util/contextHelpers.js\";\nimport React, { Component as ReactComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport throttle from 'lodash/throttle';\n/**\n * A higher order component (HOC) to take the togglePageClassNames function from\n * the context that the Page component has provided.\n */\n\nexport const withTogglePageClassNames = Component => {\n  const WithTogglePageClassNamesComponent = (props, context) => React.createElement(Component, Object.assign({\n    togglePageClassNames: context.togglePageClassNames\n  }, props, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 11\n    },\n    __self: this\n  }));\n\n  WithTogglePageClassNamesComponent.displayName = \"withTogglePageClassNames(\".concat(Component.displayName || Component.name, \")\");\n  const func = PropTypes.func;\n  WithTogglePageClassNamesComponent.contextTypes = {\n    togglePageClassNames: func.isRequired\n  };\n  return WithTogglePageClassNamesComponent;\n};\n/**\n * A higher order component (HOC) that provides the current viewport\n * dimensions to the wrapped component as a `viewport` prop that has\n * the shape `{ width: 600, height: 400}`.\n */\n\nexport const withViewport = Component => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const WAIT_MS = 100;\n\n  class WithViewportComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = this.handleWindowResize.bind(this);\n      this.setViewport = throttle(this.setViewport.bind(this), WAIT_MS);\n    }\n\n    componentDidMount() {\n      this.setViewport();\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n    }\n\n    handleWindowResize() {\n      this.setViewport();\n    }\n\n    setViewport() {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    }\n\n    render() {\n      const viewport = this.state;\n\n      const props = _objectSpread({}, this.props, {\n        viewport\n      });\n\n      return React.createElement(Component, Object.assign({}, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 65\n        },\n        __self: this\n      }));\n    }\n\n  }\n\n  WithViewportComponent.displayName = \"withViewport(\".concat(Component.displayName || Component.name, \")\");\n  return WithViewportComponent;\n};\n/**\n * A higher order component (HOC) that provides dimensions to the wrapped component as a\n * `dimensions` prop that has the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight.\n *\n * @return {Object} HOC component which knows its dimensions\n */\n\nexport const withDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200; // First render default wait after mounting (small wait for styled paint)\n\n  const RENDER_WAIT_MS = 100;\n\n  class WithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        this.setDimensions();\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n    }\n\n    handleWindowResize() {\n      window.requestAnimationFrame(() => {\n        this.setDimensions();\n      });\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const _ref = this.element || {\n          clientWidth: 0,\n          clientHeight: 0\n        },\n              clientWidth = _ref.clientWidth,\n              clientHeight = _ref.clientHeight;\n\n        return {\n          width: clientWidth,\n          height: clientHeight\n        };\n      });\n    }\n\n    render() {\n      // Dimensions from state (i.e. dimension after previous resize)\n      // These are needed for component rerenders\n      const _this$state = this.state,\n            width = _this$state.width,\n            height = _this$state.height; // Current dimensions from element reference\n\n      const _ref2 = this.element || {\n        clientWidth: 0,\n        clientHeight: 0\n      },\n            clientWidth = _ref2.clientWidth,\n            clientHeight = _ref2.clientHeight;\n\n      const hasDimensions = width !== 0 && height !== 0 || clientWidth !== 0 && clientHeight !== 0; // clientWidth and clientHeight\n\n      const currentDimensions = clientWidth !== 0 && clientHeight !== 0 ? {\n        width: clientWidth,\n        height: clientHeight\n      } : width !== 0 && height !== 0 ? {\n        width,\n        height\n      } : {};\n\n      const props = _objectSpread({}, this.props, {\n        dimensions: currentDimensions\n      }); // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n\n\n      const maxWidth = options.maxWidth,\n            maxHeight = options.maxHeight;\n      const maxWidthMaybe = maxWidth ? {\n        maxWidth\n      } : {};\n      const maxHeightMaybe = maxHeight ? {\n        maxHeight\n      } : {};\n      const style = maxWidth || maxHeight ? _objectSpread({\n        width: '100%',\n        height: '100%'\n      }, maxWidthMaybe, maxHeightMaybe) : {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      return React.createElement(\"div\", {\n        ref: element => {\n          this.element = element;\n        },\n        style: style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 162\n        },\n        __self: this\n      }, hasDimensions ? React.createElement(Component, Object.assign({}, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 168\n        },\n        __self: this\n      })) : null);\n    }\n\n  }\n\n  WithDimensionsComponent.displayName = \"withDimensions(\".concat(Component.displayName || Component.name, \")\");\n  return WithDimensionsComponent;\n};\n/**\n * A higher order component (HOC) that lazy loads the current element and provides\n * dimensions to the wrapped component as a `dimensions` prop that has\n * the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight. To load component after\n * initial rendering has passed or after user has interacted with the window (e.g. scrolled),\n * use`loadAfterInitialRendering: 1500` (value should be milliseconds).\n *\n * @return {Object} HOC component which knows its dimensions\n */\n\nexport const lazyLoadWithDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200; // First render default wait after mounting (small wait for styled paint)\n\n  const RENDER_WAIT_MS = 100; // Scrolling and other events that affect to viewport location have this safety margin\n  // for lazy loading\n\n  const NEAR_VIEWPORT_MARGIN = 50;\n\n  class LazyLoadWithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.afterRenderTimeout = null;\n      this.state = {\n        width: 0,\n        height: 0\n      };\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.isElementNearViewport = this.isElementNearViewport.bind(this);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('scroll', this.handleWindowResize);\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        if (this.isElementNearViewport(0)) {\n          this.setDimensions();\n        } else {\n          const loadAfterInitialRendering = options.loadAfterInitialRendering;\n\n          if (typeof loadAfterInitialRendering === 'number') {\n            this.afterRenderTimeout = window.setTimeout(() => {\n              window.requestAnimationFrame(() => {\n                this.setDimensions();\n              });\n            }, loadAfterInitialRendering);\n          }\n        }\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('scroll', this.handleWindowResize);\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n\n      if (this.afterRenderTimeout) {\n        window.clearTimeout(this.afterRenderTimeout);\n      }\n    }\n\n    handleWindowResize() {\n      const shouldLoadToImproveScrolling = typeof options.loadAfterInitialRendering === 'number';\n\n      if (this.isElementNearViewport(NEAR_VIEWPORT_MARGIN) || shouldLoadToImproveScrolling) {\n        window.requestAnimationFrame(() => {\n          this.setDimensions();\n        });\n      }\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const _ref3 = this.element || {\n          clientWidth: 0,\n          clientHeight: 0\n        },\n              clientWidth = _ref3.clientWidth,\n              clientHeight = _ref3.clientHeight;\n\n        return {\n          width: clientWidth,\n          height: clientHeight\n        };\n      });\n    }\n\n    isElementNearViewport(safetyBoundary) {\n      if (this.element) {\n        const rect = this.element.getBoundingClientRect();\n        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n        return rect.top >= 0 && rect.top <= viewportHeight + safetyBoundary || rect.bottom >= -1 * safetyBoundary && rect.bottom <= viewportHeight;\n      }\n\n      return false;\n    }\n\n    render() {\n      const dimensions = this.state;\n      const width = dimensions.width,\n            height = dimensions.height;\n\n      const props = _objectSpread({}, this.props, {\n        dimensions\n      }); // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n\n\n      const maxWidth = options.maxWidth,\n            maxHeight = options.maxHeight;\n      const maxWidthMaybe = maxWidth ? {\n        maxWidth\n      } : {};\n      const maxHeightMaybe = maxHeight ? {\n        maxHeight\n      } : {};\n      const style = maxWidth || maxHeight ? _objectSpread({\n        width: '100%',\n        height: '100%'\n      }, maxWidthMaybe, maxHeightMaybe) : {\n        position: 'absolute',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      return React.createElement(\"div\", {\n        ref: element => {\n          this.element = element;\n        },\n        style: style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 295\n        },\n        __self: this\n      }, width !== 0 && height !== 0 ? React.createElement(Component, Object.assign({}, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 301\n        },\n        __self: this\n      })) : null);\n    }\n\n  }\n\n  LazyLoadWithDimensionsComponent.displayName = \"lazyLoadWithDimensions(\".concat(Component.displayName || Component.name, \")\");\n  return LazyLoadWithDimensionsComponent;\n};","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/util/contextHelpers.js"],"names":["React","Component","ReactComponent","PropTypes","throttle","withTogglePageClassNames","WithTogglePageClassNamesComponent","props","context","togglePageClassNames","displayName","name","func","contextTypes","isRequired","withViewport","WAIT_MS","WithViewportComponent","constructor","state","width","height","handleWindowResize","bind","setViewport","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","setState","innerWidth","innerHeight","render","viewport","withDimensions","options","THROTTLE_WAIT_MS","RENDER_WAIT_MS","WithDimensionsComponent","element","defaultRenderTimeout","setDimensions","setTimeout","clearTimeout","requestAnimationFrame","prevState","clientWidth","clientHeight","hasDimensions","currentDimensions","dimensions","maxWidth","maxHeight","maxWidthMaybe","maxHeightMaybe","style","position","top","right","bottom","left","lazyLoadWithDimensions","NEAR_VIEWPORT_MARGIN","LazyLoadWithDimensionsComponent","afterRenderTimeout","isElementNearViewport","loadAfterInitialRendering","shouldLoadToImproveScrolling","safetyBoundary","rect","getBoundingClientRect","viewportHeight","document","documentElement"],"mappings":"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","sourcesContent":["import React, { Component as ReactComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport throttle from 'lodash/throttle';\n\n/**\n * A higher order component (HOC) to take the togglePageClassNames function from\n * the context that the Page component has provided.\n */\nexport const withTogglePageClassNames = Component => {\n  const WithTogglePageClassNamesComponent = (props, context) => (\n    <Component togglePageClassNames={context.togglePageClassNames} {...props} />\n  );\n\n  WithTogglePageClassNamesComponent.displayName = `withTogglePageClassNames(${Component.displayName ||\n    Component.name})`;\n\n  const { func } = PropTypes;\n\n  WithTogglePageClassNamesComponent.contextTypes = {\n    togglePageClassNames: func.isRequired,\n  };\n\n  return WithTogglePageClassNamesComponent;\n};\n\n/**\n * A higher order component (HOC) that provides the current viewport\n * dimensions to the wrapped component as a `viewport` prop that has\n * the shape `{ width: 600, height: 400}`.\n */\nexport const withViewport = Component => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const WAIT_MS = 100;\n\n  class WithViewportComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.state = { width: 0, height: 0 };\n      this.handleWindowResize = this.handleWindowResize.bind(this);\n      this.setViewport = throttle(this.setViewport.bind(this), WAIT_MS);\n    }\n    componentDidMount() {\n      this.setViewport();\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n    }\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n    }\n    handleWindowResize() {\n      this.setViewport();\n    }\n    setViewport() {\n      this.setState({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n    render() {\n      const viewport = this.state;\n      const props = { ...this.props, viewport };\n      return <Component {...props} />;\n    }\n  }\n\n  WithViewportComponent.displayName = `withViewport(${Component.displayName || Component.name})`;\n\n  return WithViewportComponent;\n};\n\n/**\n * A higher order component (HOC) that provides dimensions to the wrapped component as a\n * `dimensions` prop that has the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight.\n *\n * @return {Object} HOC component which knows its dimensions\n */\nexport const withDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200;\n  // First render default wait after mounting (small wait for styled paint)\n  const RENDER_WAIT_MS = 100;\n\n  class WithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n\n      this.state = { width: 0, height: 0 };\n\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        this.setDimensions();\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n    }\n\n    handleWindowResize() {\n      window.requestAnimationFrame(() => {\n        this.setDimensions();\n      });\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n        return { width: clientWidth, height: clientHeight };\n      });\n    }\n\n    render() {\n      // Dimensions from state (i.e. dimension after previous resize)\n      // These are needed for component rerenders\n      const { width, height } = this.state;\n\n      // Current dimensions from element reference\n      const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n      const hasDimensions =\n        (width !== 0 && height !== 0) || (clientWidth !== 0 && clientHeight !== 0);\n\n      // clientWidth and clientHeight\n      const currentDimensions =\n        clientWidth !== 0 && clientHeight !== 0\n          ? { width: clientWidth, height: clientHeight }\n          : width !== 0 && height !== 0\n          ? { width, height }\n          : {};\n\n      const props = { ...this.props, dimensions: currentDimensions };\n\n      // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n      const { maxWidth, maxHeight } = options;\n      const maxWidthMaybe = maxWidth ? { maxWidth } : {};\n      const maxHeightMaybe = maxHeight ? { maxHeight } : {};\n      const style =\n        maxWidth || maxHeight\n          ? { width: '100%', height: '100%', ...maxWidthMaybe, ...maxHeightMaybe }\n          : { position: 'absolute', top: 0, right: 0, bottom: 0, left: 0 };\n\n      return (\n        <div\n          ref={element => {\n            this.element = element;\n          }}\n          style={style}\n        >\n          {hasDimensions ? <Component {...props} /> : null}\n        </div>\n      );\n    }\n  }\n\n  WithDimensionsComponent.displayName = `withDimensions(${Component.displayName ||\n    Component.name})`;\n\n  return WithDimensionsComponent;\n};\n\n/**\n * A higher order component (HOC) that lazy loads the current element and provides\n * dimensions to the wrapped component as a `dimensions` prop that has\n * the shape `{ width: 600, height: 400}`.\n *\n * @param {React.Component} Component to be wrapped by this HOC\n * @param {Object} options pass in options like maxWidth and maxHeight. To load component after\n * initial rendering has passed or after user has interacted with the window (e.g. scrolled),\n * use`loadAfterInitialRendering: 1500` (value should be milliseconds).\n *\n * @return {Object} HOC component which knows its dimensions\n */\nexport const lazyLoadWithDimensions = (Component, options = {}) => {\n  // The resize event is flooded when the browser is resized. We'll\n  // use a small timeout to throttle changing the viewport since it\n  // will trigger rerendering.\n  const THROTTLE_WAIT_MS = 200;\n  // First render default wait after mounting (small wait for styled paint)\n  const RENDER_WAIT_MS = 100;\n\n  // Scrolling and other events that affect to viewport location have this safety margin\n  // for lazy loading\n  const NEAR_VIEWPORT_MARGIN = 50;\n\n  class LazyLoadWithDimensionsComponent extends ReactComponent {\n    constructor(props) {\n      super(props);\n      this.element = null;\n      this.defaultRenderTimeout = null;\n      this.afterRenderTimeout = null;\n\n      this.state = { width: 0, height: 0 };\n\n      this.handleWindowResize = throttle(this.handleWindowResize.bind(this), THROTTLE_WAIT_MS);\n      this.isElementNearViewport = this.isElementNearViewport.bind(this);\n      this.setDimensions = this.setDimensions.bind(this);\n    }\n\n    componentDidMount() {\n      window.addEventListener('scroll', this.handleWindowResize);\n      window.addEventListener('resize', this.handleWindowResize);\n      window.addEventListener('orientationchange', this.handleWindowResize);\n\n      this.defaultRenderTimeout = window.setTimeout(() => {\n        if (this.isElementNearViewport(0)) {\n          this.setDimensions();\n        } else {\n          const loadAfterInitialRendering = options.loadAfterInitialRendering;\n          if (typeof loadAfterInitialRendering === 'number') {\n            this.afterRenderTimeout = window.setTimeout(() => {\n              window.requestAnimationFrame(() => {\n                this.setDimensions();\n              });\n            }, loadAfterInitialRendering);\n          }\n        }\n      }, RENDER_WAIT_MS);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener('scroll', this.handleWindowResize);\n      window.removeEventListener('resize', this.handleWindowResize);\n      window.removeEventListener('orientationchange', this.handleWindowResize);\n      window.clearTimeout(this.defaultRenderTimeout);\n\n      if (this.afterRenderTimeout) {\n        window.clearTimeout(this.afterRenderTimeout);\n      }\n    }\n\n    handleWindowResize() {\n      const shouldLoadToImproveScrolling = typeof options.loadAfterInitialRendering === 'number';\n      if (this.isElementNearViewport(NEAR_VIEWPORT_MARGIN) || shouldLoadToImproveScrolling) {\n        window.requestAnimationFrame(() => {\n          this.setDimensions();\n        });\n      }\n    }\n\n    setDimensions() {\n      this.setState(prevState => {\n        const { clientWidth, clientHeight } = this.element || { clientWidth: 0, clientHeight: 0 };\n        return { width: clientWidth, height: clientHeight };\n      });\n    }\n\n    isElementNearViewport(safetyBoundary) {\n      if (this.element) {\n        const rect = this.element.getBoundingClientRect();\n        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n\n        return (\n          (rect.top >= 0 && rect.top <= viewportHeight + safetyBoundary) ||\n          (rect.bottom >= -1 * safetyBoundary && rect.bottom <= viewportHeight)\n        );\n      }\n      return false;\n    }\n\n    render() {\n      const dimensions = this.state;\n      const { width, height } = dimensions;\n      const props = { ...this.props, dimensions };\n\n      // lazyLoadWithDimensions HOC needs to take all given space\n      // unless max dimensions are provided through options.\n      const { maxWidth, maxHeight } = options;\n      const maxWidthMaybe = maxWidth ? { maxWidth } : {};\n      const maxHeightMaybe = maxHeight ? { maxHeight } : {};\n      const style =\n        maxWidth || maxHeight\n          ? { width: '100%', height: '100%', ...maxWidthMaybe, ...maxHeightMaybe }\n          : { position: 'absolute', top: 0, right: 0, bottom: 0, left: 0 };\n\n      return (\n        <div\n          ref={element => {\n            this.element = element;\n          }}\n          style={style}\n        >\n          {width !== 0 && height !== 0 ? <Component {...props} /> : null}\n        </div>\n      );\n    }\n  }\n\n  LazyLoadWithDimensionsComponent.displayName = `lazyLoadWithDimensions(${Component.displayName ||\n    Component.name})`;\n\n  return LazyLoadWithDimensionsComponent;\n};\n"]},"metadata":{},"sourceType":"module"}