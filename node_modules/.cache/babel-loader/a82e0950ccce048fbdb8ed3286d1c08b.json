{"ast":null,"code":"import _objectWithoutProperties from \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/components/SearchMap/SearchMapWithMapbox.js\";\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { arrayOf, func, node, number, shape, string } from 'prop-types';\nimport differenceBy from 'lodash/differenceBy';\nimport isEqual from 'lodash/isEqual';\nimport classNames from 'classnames';\nimport { types as sdkTypes } from '../../util/sdkLoader';\nimport { parse } from '../../util/urlHelpers';\nimport { propTypes } from '../../util/types';\nimport { ensureListing } from '../../util/data';\nimport { sdkBoundsToFixedCoordinates, hasSameSDKBounds } from '../../util/maps';\nimport { SearchMapInfoCard, SearchMapPriceLabel, SearchMapGroupLabel } from '../../components';\nimport { groupedByCoordinates, reducedToArray } from './SearchMap.helpers.js';\nimport css from './SearchMapWithMapbox.css';\nexport const LABEL_HANDLE = 'SearchMapLabel';\nexport const INFO_CARD_HANDLE = 'SearchMapInfoCard';\nexport const SOURCE_AUTOCOMPLETE = 'autocomplete';\nconst BOUNDS_FIXED_PRECISION = 8;\nconst SDKLatLng = sdkTypes.LatLng,\n      SDKLatLngBounds = sdkTypes.LatLngBounds;\n/**\n * Fit part of map (descriped with bounds) to visible map-viewport\n *\n * @param {Object} map - map that needs to be centered with given bounds\n * @param {SDK.LatLngBounds} bounds - the area that needs to be visible when map loads.\n */\n\nexport const fitMapToBounds = (map, bounds, options) => {\n  const _options$padding = options.padding,\n        padding = _options$padding === void 0 ? 0 : _options$padding,\n        _options$isAutocomple = options.isAutocompleteSearch,\n        isAutocompleteSearch = _options$isAutocomple === void 0 ? false : _options$isAutocomple; // map bounds as string literal for google.maps\n\n  const mapBounds = sdkBoundsToMapboxBounds(bounds);\n  const paddingOptionMaybe = padding == null ? {\n    padding\n  } : {};\n  const eventData = isAutocompleteSearch ? {\n    searchSource: SOURCE_AUTOCOMPLETE\n  } : {}; // If bounds are given, use it (defaults to center & zoom).\n\n  if (map && mapBounds) {\n    map.fitBounds(mapBounds, _objectSpread({}, paddingOptionMaybe, {\n      linear: true,\n      duration: 0\n    }), eventData);\n  }\n};\n/**\n * Convert Mapbox formatted LatLng object to Sharetribe SDK's LatLng coordinate format\n * Longitudes > 180 and < -180 are converted to the correct corresponding value\n * between -180 and 180.\n *\n * @param {LngLat} mapboxLngLat - Mapbox LngLat\n *\n * @return {SDKLatLng} - Converted latLng coordinate\n */\n\nexport const mapboxLngLatToSDKLatLng = lngLat => {\n  const mapboxLng = lngLat.lng; // For bounding boxes that overlap the antimeridian Mapbox sometimes gives\n  // longitude values outside -180 and 180 degrees.Those values are converted\n  // so that longitude is always between -180 and 180.\n\n  const lng = mapboxLng > 180 ? mapboxLng - 360 : mapboxLng < -180 ? mapboxLng + 360 : mapboxLng;\n  return new SDKLatLng(lngLat.lat, lng);\n};\n/**\n * Convert Mapbox formatted bounds object to Sharetribe SDK's bounds format\n *\n * @param {LngLatBounds} mapboxBounds - Mapbox LngLatBounds\n *\n * @return {SDKLatLngBounds} - Converted bounds\n */\n\nexport const mapboxBoundsToSDKBounds = mapboxBounds => {\n  if (!mapboxBounds) {\n    return null;\n  }\n\n  const ne = mapboxBounds.getNorthEast();\n  const sw = mapboxBounds.getSouthWest();\n  return new SDKLatLngBounds(mapboxLngLatToSDKLatLng(ne), mapboxLngLatToSDKLatLng(sw));\n};\n/**\n * Convert sdk bounds that overlap the antimeridian into values that can\n * be passed to Mapbox. This is achieved by converting the SW longitude into\n * a value less than -180 that flows over the antimeridian.\n *\n * @param {SDKLatLng} bounds - bounds passed to the map\n *\n * @return {LngLatBoundsLike} a bounding box that is compatible with Mapbox\n */\n\nconst sdkBoundsToMapboxBounds = bounds => {\n  if (!bounds) {\n    return null;\n  }\n\n  const ne = bounds.ne,\n        sw = bounds.sw; // if sw lng is > ne lng => the bounds overlap antimeridian\n  // => flip the nw lng to the negative side so that the value\n  // is less than -180\n\n  const swLng = sw.lng > ne.lng ? -360 + sw.lng : sw.lng;\n  return [[swLng, sw.lat], [ne.lng, ne.lat]];\n};\n/**\n * Return map bounds as SDKBounds\n *\n * @param {Mapbox} map - Mapbox map from where the bounds are asked\n *\n * @return {SDKLatLngBounds} - Converted bounds of given map\n */\n\n\nexport const getMapBounds = map => mapboxBoundsToSDKBounds(map.getBounds());\n/**\n * Return map center as SDKLatLng\n *\n * @param {Mapbox} map - Mapbox map from where the center is asked\n *\n * @return {SDKLatLng} - Converted center of given map\n */\n\nexport const getMapCenter = map => mapboxLngLatToSDKLatLng(map.getCenter());\n/**\n * Check if map library is loaded\n */\n\nexport const isMapsLibLoaded = () => typeof window !== 'undefined' && window.mapboxgl && window.mapboxgl.accessToken;\n/**\n * Return price labels grouped by listing locations.\n * This is a helper function for SearchMapWithMapbox component.\n */\n\nconst priceLabelsInLocations = (listings, activeListingId, infoCardOpen, onListingClicked, mapComponentRefreshToken) => {\n  const listingArraysInLocations = reducedToArray(groupedByCoordinates(listings));\n  const priceLabels = listingArraysInLocations.reverse().map(listingArr => {\n    const isActive = activeListingId ? !!listingArr.find(l => activeListingId.uuid === l.id.uuid) : false; // If location contains only one listing, print price label\n\n    if (listingArr.length === 1) {\n      const listing = listingArr[0];\n      const infoCardOpenIds = Array.isArray(infoCardOpen) ? infoCardOpen.map(l => l.id.uuid) : infoCardOpen ? [infoCardOpen.id.uuid] : []; // if the listing is open, don't print price label\n\n      if (infoCardOpen != null && infoCardOpenIds.includes(listing.id.uuid)) {\n        return null;\n      } // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n\n\n      const geolocation = listing.attributes.geolocation;\n      const key = listing.id.uuid;\n      return {\n        markerId: \"price_\".concat(key),\n        location: geolocation,\n        type: 'price',\n        componentProps: {\n          key,\n          isActive,\n          className: LABEL_HANDLE,\n          listing,\n          onListingClicked,\n          mapComponentRefreshToken\n        }\n      };\n    } // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n\n\n    const firstListing = ensureListing(listingArr[0]);\n    const geolocation = firstListing.attributes.geolocation;\n    const key = listingArr[0].id.uuid;\n    return {\n      markerId: \"group_\".concat(key),\n      location: geolocation,\n      type: 'group',\n      componentProps: {\n        key,\n        isActive,\n        className: LABEL_HANDLE,\n        listings: listingArr,\n        onListingClicked,\n        mapComponentRefreshToken\n      }\n    };\n  });\n  return priceLabels;\n};\n/**\n * Return info card. This is a helper function for SearchMapWithMapbox component.\n */\n\n\nconst infoCardComponent = (infoCardOpen, onListingInfoCardClicked, createURLToListing, mapComponentRefreshToken) => {\n  const listingsArray = Array.isArray(infoCardOpen) ? infoCardOpen : [infoCardOpen];\n\n  if (!infoCardOpen) {\n    return null;\n  }\n\n  const firstListing = ensureListing(listingsArray[0]);\n  const key = firstListing.id.uuid;\n  const geolocation = firstListing.attributes.geolocation;\n  return {\n    markerId: \"infoCard_\".concat(key),\n    location: geolocation,\n    componentProps: {\n      key,\n      mapComponentRefreshToken,\n      className: INFO_CARD_HANDLE,\n      listings: listingsArray,\n      onListingInfoCardClicked,\n      createURLToListing\n    }\n  };\n};\n/**\n * SearchMap component using Mapbox as map provider\n */\n\n\nclass SearchMapWithMapbox extends Component {\n  constructor(props) {\n    super(props);\n    this.map = typeof window !== 'undefined' && window.mapboxMap ? window.mapboxMap : null;\n    this.currentMarkers = [];\n    this.currentInfoCard = null;\n    this.state = {\n      mapContainer: null,\n      isMapReady: false\n    };\n    this.viewportBounds = null;\n    this.onMount = this.onMount.bind(this);\n    this.onMoveend = this.onMoveend.bind(this);\n    this.initializeMap = this.initializeMap.bind(this);\n    this.handleDoubleClickOnInfoCard = this.handleDoubleClickOnInfoCard.bind(this);\n    this.handleMobilePinchZoom = this.handleMobilePinchZoom.bind(this);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (!isEqual(this.props.location, nextProps.location)) {\n      // If no mapSearch url parameter is given, this is original location search\n      const _parse = parse(nextProps.location.search, {\n        latlng: ['origin'],\n        latlngBounds: ['bounds']\n      }),\n            mapSearch = _parse.mapSearch;\n\n      if (!mapSearch) {\n        this.viewportBounds = null;\n      }\n    }\n\n    if (this.map) {\n      const currentBounds = getMapBounds(this.map); // Do not call fitMapToBounds if bounds are the same.\n      // Our bounds are viewport bounds, and fitBounds will try to add margins around those bounds\n      // that would result to zoom-loop (bound change -> fitmap -> bounds change -> ...)\n\n      if (!isEqual(nextProps.bounds, currentBounds) && !this.viewportBounds) {\n        fitMapToBounds(this.map, nextProps.bounds, {\n          padding: 0,\n          isAutocompleteSearch: true\n        });\n      }\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!this.map && this.state.mapContainer) {\n      this.initializeMap();\n      /* Notify parent component that Mapbox map is loaded */\n\n      this.props.onMapLoad(this.map);\n    } else if (prevProps.mapComponentRefreshToken !== this.props.mapComponentRefreshToken) {\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    }\n  }\n\n  componentWillUnmount() {\n    this.currentInfoCard.markerContainer.removeEventListener('dblclick', this.handleDoubleClickOnInfoCard);\n    document.removeEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gestureend', this.handleMobilePinchZoom, false);\n  }\n\n  onMount(element) {\n    // This prevents pinch zoom to affect whole page on mobile Safari.\n    document.addEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.addEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.addEventListener('gestureend', this.handleMobilePinchZoom, false);\n    this.setState({\n      mapContainer: element\n    });\n  }\n\n  onMoveend(e) {\n    if (this.map) {\n      // If reusableMapHiddenHandle is given and parent element has that class,\n      // we don't listen moveend events.\n      // This fixes mobile Chrome bug that sends map events to invisible map components.\n      const isHiddenByReusableMap = this.props.reusableMapHiddenHandle && this.state.mapContainer.parentElement.classList.contains(this.props.reusableMapHiddenHandle);\n\n      if (!isHiddenByReusableMap) {\n        const viewportMapBounds = getMapBounds(this.map);\n        const viewportMapCenter = getMapCenter(this.map);\n        const viewportBounds = sdkBoundsToFixedCoordinates(viewportMapBounds, BOUNDS_FIXED_PRECISION); // ViewportBounds from (previous) rendering differ from viewportBounds currently set to map\n        // I.e. user has changed the map somehow: moved, panned, zoomed, resized\n\n        const viewportBoundsChanged = this.viewportBounds && !hasSameSDKBounds(this.viewportBounds, viewportBounds);\n        this.props.onMapMoveEnd(viewportBoundsChanged, {\n          viewportBounds,\n          viewportMapCenter\n        });\n        this.viewportBounds = viewportBounds;\n      }\n    }\n  }\n\n  initializeMap() {\n    const _this$state$mapContai = this.state.mapContainer,\n          offsetHeight = _this$state$mapContai.offsetHeight,\n          offsetWidth = _this$state$mapContai.offsetWidth;\n    const hasDimensions = offsetHeight > 0 && offsetWidth > 0;\n\n    if (hasDimensions) {\n      this.map = new window.mapboxgl.Map({\n        container: this.state.mapContainer,\n        style: 'mapbox://styles/mapbox/streets-v10',\n        scrollZoom: false\n      });\n      window.mapboxMap = this.map;\n      var nav = new window.mapboxgl.NavigationControl({\n        showCompass: false\n      });\n      this.map.addControl(nav, 'top-left');\n      this.map.on('moveend', this.onMoveend); // Introduce rerendering after map is ready (to include labels),\n      // but keep the map out of state life cycle.\n\n      this.setState({\n        isMapReady: true\n      });\n    }\n  }\n\n  handleMobilePinchZoom(e) {\n    e.preventDefault(); // A hack to prevent pinch zoom gesture in mobile Safari\n    // Otherwise, pinch zoom would zoom both map and the document.\n\n    document.body.style.zoom = 0.99;\n  }\n\n  handleDoubleClickOnInfoCard(e) {\n    e.stopPropagation();\n  }\n\n  render() {\n    const _this$props = this.props,\n          className = _this$props.className,\n          listings = _this$props.listings,\n          activeListingId = _this$props.activeListingId,\n          infoCardOpen = _this$props.infoCardOpen,\n          onListingClicked = _this$props.onListingClicked,\n          onListingInfoCardClicked = _this$props.onListingInfoCardClicked,\n          createURLToListing = _this$props.createURLToListing,\n          mapComponentRefreshToken = _this$props.mapComponentRefreshToken;\n\n    if (this.map) {\n      // Create markers out of price labels and grouped labels\n      const labels = priceLabelsInLocations(listings, activeListingId, infoCardOpen, onListingClicked, mapComponentRefreshToken); // If map has moved or info card opened, unnecessary markers need to be removed\n\n      const removableMarkers = differenceBy(this.currentMarkers, labels, 'markerId');\n      removableMarkers.forEach(rm => rm.marker.remove()); // Helper function to create markers to given container\n\n      const createMarker = (data, markerContainer) => new window.mapboxgl.Marker(markerContainer, {\n        anchor: 'bottom'\n      }).setLngLat([data.location.lng, data.location.lat]).addTo(this.map); // SearchMapPriceLabel and SearchMapGroupLabel:\n      // create a new marker or use existing one if markerId is among previously rendered markers\n\n\n      this.currentMarkers = labels.filter(v => v != null).map(m => {\n        const existingMarkerId = this.currentMarkers.findIndex(marker => m.markerId === marker.markerId && marker.marker);\n\n        if (existingMarkerId >= 0) {\n          const _this$currentMarkers$ = this.currentMarkers[existingMarkerId],\n                marker = _this$currentMarkers$.marker,\n                markerContainer = _this$currentMarkers$.markerContainer,\n                rest = _objectWithoutProperties(_this$currentMarkers$, [\"marker\", \"markerContainer\"]);\n\n          return _objectSpread({}, rest, m, {\n            markerContainer,\n            marker\n          });\n        } else {\n          const markerContainer = document.createElement('div');\n          markerContainer.setAttribute('id', m.markerId);\n          markerContainer.classList.add(css.labelContainer);\n          const marker = createMarker(m, markerContainer);\n          return _objectSpread({}, m, {\n            markerContainer,\n            marker\n          });\n        }\n      });\n      /* Create marker for SearchMapInfoCard component */\n\n      if (infoCardOpen) {\n        const infoCard = infoCardComponent(infoCardOpen, onListingInfoCardClicked, createURLToListing, mapComponentRefreshToken); // marker container and its styles\n\n        const infoCardContainer = document.createElement('div');\n        infoCardContainer.setAttribute('id', infoCard.markerId);\n        infoCardContainer.classList.add(css.infoCardContainer);\n        infoCardContainer.addEventListener('dblclick', this.handleDoubleClickOnInfoCard, false);\n        this.currentInfoCard = _objectSpread({}, infoCard, {\n          markerContainer: infoCardContainer,\n          marker: infoCard ? createMarker(infoCard, infoCardContainer) : null\n        });\n      } else {\n        if (this.currentInfoCard) {\n          this.currentInfoCard.markerContainer.removeEventListener('dblclick', this.handleDoubleClickOnInfoCard);\n        }\n\n        this.currentInfoCard = null;\n      }\n    }\n\n    return React.createElement(\"div\", {\n      id: \"map\",\n      ref: this.onMount,\n      className: classNames(className, css.fullArea),\n      onClick: this.props.onClick,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 454\n      },\n      __self: this\n    }, this.currentMarkers.map(m => {\n      // Remove existing activeLabel classes and add it only to the correct container\n      m.markerContainer.classList.remove(css.activeLabel);\n\n      if (activeListingId && activeListingId.uuid === m.componentProps.key) {\n        m.markerContainer.classList.add(css.activeLabel);\n      }\n\n      const isMapReadyForMarkers = this.map && m.markerContainer; // DOM node that should be used as portal's root\n\n      const portalDOMContainer = isMapReadyForMarkers ? document.getElementById(m.markerContainer.id) : null; // Create component portals for correct marker containers\n\n      if (isMapReadyForMarkers && m.type === 'price') {\n        return ReactDOM.createPortal(React.createElement(SearchMapPriceLabel, Object.assign({}, m.componentProps, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 476\n          },\n          __self: this\n        })), portalDOMContainer);\n      } else if (isMapReadyForMarkers && m.type === 'group') {\n        return ReactDOM.createPortal(React.createElement(SearchMapGroupLabel, Object.assign({}, m.componentProps, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 481\n          },\n          __self: this\n        })), portalDOMContainer);\n      }\n\n      return null;\n    }), this.state.mapContainer && this.currentInfoCard ? ReactDOM.createPortal(React.createElement(SearchMapInfoCard, Object.assign({}, this.currentInfoCard.componentProps, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 489\n      },\n      __self: this\n    })), this.currentInfoCard.markerContainer) : null);\n  }\n\n}\n\nSearchMapWithMapbox.defaultProps = {\n  center: null,\n  priceLabels: [],\n  infoCard: null,\n  zoom: 11,\n  reusableMapHiddenHandle: null\n};\nSearchMapWithMapbox.propTypes = {\n  center: propTypes.latlng,\n  location: shape({\n    search: string.isRequired\n  }).isRequired,\n  priceLabels: arrayOf(node),\n  infoCard: node,\n  onClick: func.isRequired,\n  onMapMoveEnd: func.isRequired,\n  onMapLoad: func.isRequired,\n  zoom: number,\n  reusableMapHiddenHandle: string\n};\nexport default SearchMapWithMapbox;","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/components/SearchMap/SearchMapWithMapbox.js"],"names":["React","Component","ReactDOM","arrayOf","func","node","number","shape","string","differenceBy","isEqual","classNames","types","sdkTypes","parse","propTypes","ensureListing","sdkBoundsToFixedCoordinates","hasSameSDKBounds","SearchMapInfoCard","SearchMapPriceLabel","SearchMapGroupLabel","groupedByCoordinates","reducedToArray","css","LABEL_HANDLE","INFO_CARD_HANDLE","SOURCE_AUTOCOMPLETE","BOUNDS_FIXED_PRECISION","SDKLatLng","LatLng","SDKLatLngBounds","LatLngBounds","fitMapToBounds","map","bounds","options","padding","isAutocompleteSearch","mapBounds","sdkBoundsToMapboxBounds","paddingOptionMaybe","eventData","searchSource","fitBounds","linear","duration","mapboxLngLatToSDKLatLng","lngLat","mapboxLng","lng","lat","mapboxBoundsToSDKBounds","mapboxBounds","ne","getNorthEast","sw","getSouthWest","swLng","getMapBounds","getBounds","getMapCenter","getCenter","isMapsLibLoaded","window","mapboxgl","accessToken","priceLabelsInLocations","listings","activeListingId","infoCardOpen","onListingClicked","mapComponentRefreshToken","listingArraysInLocations","priceLabels","reverse","listingArr","isActive","find","l","uuid","id","length","listing","infoCardOpenIds","Array","isArray","includes","geolocation","attributes","key","markerId","location","type","componentProps","className","firstListing","infoCardComponent","onListingInfoCardClicked","createURLToListing","listingsArray","SearchMapWithMapbox","constructor","props","mapboxMap","currentMarkers","currentInfoCard","state","mapContainer","isMapReady","viewportBounds","onMount","bind","onMoveend","initializeMap","handleDoubleClickOnInfoCard","handleMobilePinchZoom","componentWillReceiveProps","nextProps","search","latlng","latlngBounds","mapSearch","currentBounds","componentDidUpdate","prevProps","onMapLoad","componentWillUnmount","markerContainer","removeEventListener","document","element","addEventListener","setState","e","isHiddenByReusableMap","reusableMapHiddenHandle","parentElement","classList","contains","viewportMapBounds","viewportMapCenter","viewportBoundsChanged","onMapMoveEnd","offsetHeight","offsetWidth","hasDimensions","Map","container","style","scrollZoom","nav","NavigationControl","showCompass","addControl","on","preventDefault","body","zoom","stopPropagation","render","labels","removableMarkers","forEach","rm","marker","remove","createMarker","data","Marker","anchor","setLngLat","addTo","filter","v","m","existingMarkerId","findIndex","rest","createElement","setAttribute","add","labelContainer","infoCard","infoCardContainer","fullArea","onClick","activeLabel","isMapReadyForMarkers","portalDOMContainer","getElementById","createPortal","defaultProps","center","isRequired"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { arrayOf, func, node, number, shape, string } from 'prop-types';\nimport differenceBy from 'lodash/differenceBy';\nimport isEqual from 'lodash/isEqual';\nimport classNames from 'classnames';\nimport { types as sdkTypes } from '../../util/sdkLoader';\nimport { parse } from '../../util/urlHelpers';\nimport { propTypes } from '../../util/types';\nimport { ensureListing } from '../../util/data';\nimport { sdkBoundsToFixedCoordinates, hasSameSDKBounds } from '../../util/maps';\nimport { SearchMapInfoCard, SearchMapPriceLabel, SearchMapGroupLabel } from '../../components';\n\nimport { groupedByCoordinates, reducedToArray } from './SearchMap.helpers.js';\nimport css from './SearchMapWithMapbox.css';\n\nexport const LABEL_HANDLE = 'SearchMapLabel';\nexport const INFO_CARD_HANDLE = 'SearchMapInfoCard';\nexport const SOURCE_AUTOCOMPLETE = 'autocomplete';\nconst BOUNDS_FIXED_PRECISION = 8;\n\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\n\n/**\n * Fit part of map (descriped with bounds) to visible map-viewport\n *\n * @param {Object} map - map that needs to be centered with given bounds\n * @param {SDK.LatLngBounds} bounds - the area that needs to be visible when map loads.\n */\nexport const fitMapToBounds = (map, bounds, options) => {\n  const { padding = 0, isAutocompleteSearch = false } = options;\n\n  // map bounds as string literal for google.maps\n  const mapBounds = sdkBoundsToMapboxBounds(bounds);\n  const paddingOptionMaybe = padding == null ? { padding } : {};\n  const eventData = isAutocompleteSearch ? { searchSource: SOURCE_AUTOCOMPLETE } : {};\n\n  // If bounds are given, use it (defaults to center & zoom).\n  if (map && mapBounds) {\n    map.fitBounds(mapBounds, { ...paddingOptionMaybe, linear: true, duration: 0 }, eventData);\n  }\n};\n\n/**\n * Convert Mapbox formatted LatLng object to Sharetribe SDK's LatLng coordinate format\n * Longitudes > 180 and < -180 are converted to the correct corresponding value\n * between -180 and 180.\n *\n * @param {LngLat} mapboxLngLat - Mapbox LngLat\n *\n * @return {SDKLatLng} - Converted latLng coordinate\n */\nexport const mapboxLngLatToSDKLatLng = lngLat => {\n  const mapboxLng = lngLat.lng;\n\n  // For bounding boxes that overlap the antimeridian Mapbox sometimes gives\n  // longitude values outside -180 and 180 degrees.Those values are converted\n  // so that longitude is always between -180 and 180.\n  const lng = mapboxLng > 180 ? mapboxLng - 360 : mapboxLng < -180 ? mapboxLng + 360 : mapboxLng;\n\n  return new SDKLatLng(lngLat.lat, lng);\n};\n\n/**\n * Convert Mapbox formatted bounds object to Sharetribe SDK's bounds format\n *\n * @param {LngLatBounds} mapboxBounds - Mapbox LngLatBounds\n *\n * @return {SDKLatLngBounds} - Converted bounds\n */\nexport const mapboxBoundsToSDKBounds = mapboxBounds => {\n  if (!mapboxBounds) {\n    return null;\n  }\n\n  const ne = mapboxBounds.getNorthEast();\n  const sw = mapboxBounds.getSouthWest();\n  return new SDKLatLngBounds(mapboxLngLatToSDKLatLng(ne), mapboxLngLatToSDKLatLng(sw));\n};\n\n/**\n * Convert sdk bounds that overlap the antimeridian into values that can\n * be passed to Mapbox. This is achieved by converting the SW longitude into\n * a value less than -180 that flows over the antimeridian.\n *\n * @param {SDKLatLng} bounds - bounds passed to the map\n *\n * @return {LngLatBoundsLike} a bounding box that is compatible with Mapbox\n */\nconst sdkBoundsToMapboxBounds = bounds => {\n  if (!bounds) {\n    return null;\n  }\n  const { ne, sw } = bounds;\n\n  // if sw lng is > ne lng => the bounds overlap antimeridian\n  // => flip the nw lng to the negative side so that the value\n  // is less than -180\n  const swLng = sw.lng > ne.lng ? -360 + sw.lng : sw.lng;\n\n  return [[swLng, sw.lat], [ne.lng, ne.lat]];\n};\n\n/**\n * Return map bounds as SDKBounds\n *\n * @param {Mapbox} map - Mapbox map from where the bounds are asked\n *\n * @return {SDKLatLngBounds} - Converted bounds of given map\n */\nexport const getMapBounds = map => mapboxBoundsToSDKBounds(map.getBounds());\n\n/**\n * Return map center as SDKLatLng\n *\n * @param {Mapbox} map - Mapbox map from where the center is asked\n *\n * @return {SDKLatLng} - Converted center of given map\n */\nexport const getMapCenter = map => mapboxLngLatToSDKLatLng(map.getCenter());\n\n/**\n * Check if map library is loaded\n */\nexport const isMapsLibLoaded = () =>\n  typeof window !== 'undefined' && window.mapboxgl && window.mapboxgl.accessToken;\n\n/**\n * Return price labels grouped by listing locations.\n * This is a helper function for SearchMapWithMapbox component.\n */\nconst priceLabelsInLocations = (\n  listings,\n  activeListingId,\n  infoCardOpen,\n  onListingClicked,\n  mapComponentRefreshToken\n) => {\n  const listingArraysInLocations = reducedToArray(groupedByCoordinates(listings));\n  const priceLabels = listingArraysInLocations.reverse().map(listingArr => {\n    const isActive = activeListingId\n      ? !!listingArr.find(l => activeListingId.uuid === l.id.uuid)\n      : false;\n\n    // If location contains only one listing, print price label\n    if (listingArr.length === 1) {\n      const listing = listingArr[0];\n      const infoCardOpenIds = Array.isArray(infoCardOpen)\n        ? infoCardOpen.map(l => l.id.uuid)\n        : infoCardOpen\n        ? [infoCardOpen.id.uuid]\n        : [];\n\n      // if the listing is open, don't print price label\n      if (infoCardOpen != null && infoCardOpenIds.includes(listing.id.uuid)) {\n        return null;\n      }\n\n      // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n      const { geolocation } = listing.attributes;\n\n      const key = listing.id.uuid;\n      return {\n        markerId: `price_${key}`,\n        location: geolocation,\n        type: 'price',\n        componentProps: {\n          key,\n          isActive,\n          className: LABEL_HANDLE,\n          listing,\n          onListingClicked,\n          mapComponentRefreshToken,\n        },\n      };\n    }\n\n    // Explicit type change to object literal for Google OverlayViews (geolocation is SDK type)\n    const firstListing = ensureListing(listingArr[0]);\n    const geolocation = firstListing.attributes.geolocation;\n\n    const key = listingArr[0].id.uuid;\n    return {\n      markerId: `group_${key}`,\n      location: geolocation,\n      type: 'group',\n      componentProps: {\n        key,\n        isActive,\n        className: LABEL_HANDLE,\n        listings: listingArr,\n        onListingClicked,\n        mapComponentRefreshToken,\n      },\n    };\n  });\n  return priceLabels;\n};\n\n/**\n * Return info card. This is a helper function for SearchMapWithMapbox component.\n */\nconst infoCardComponent = (\n  infoCardOpen,\n  onListingInfoCardClicked,\n  createURLToListing,\n  mapComponentRefreshToken\n) => {\n  const listingsArray = Array.isArray(infoCardOpen) ? infoCardOpen : [infoCardOpen];\n\n  if (!infoCardOpen) {\n    return null;\n  }\n\n  const firstListing = ensureListing(listingsArray[0]);\n  const key = firstListing.id.uuid;\n  const geolocation = firstListing.attributes.geolocation;\n\n  return {\n    markerId: `infoCard_${key}`,\n    location: geolocation,\n    componentProps: {\n      key,\n      mapComponentRefreshToken,\n      className: INFO_CARD_HANDLE,\n      listings: listingsArray,\n      onListingInfoCardClicked,\n      createURLToListing,\n    },\n  };\n};\n\n/**\n * SearchMap component using Mapbox as map provider\n */\nclass SearchMapWithMapbox extends Component {\n  constructor(props) {\n    super(props);\n    this.map = typeof window !== 'undefined' && window.mapboxMap ? window.mapboxMap : null;\n    this.currentMarkers = [];\n    this.currentInfoCard = null;\n    this.state = { mapContainer: null, isMapReady: false };\n    this.viewportBounds = null;\n\n    this.onMount = this.onMount.bind(this);\n    this.onMoveend = this.onMoveend.bind(this);\n    this.initializeMap = this.initializeMap.bind(this);\n    this.handleDoubleClickOnInfoCard = this.handleDoubleClickOnInfoCard.bind(this);\n    this.handleMobilePinchZoom = this.handleMobilePinchZoom.bind(this);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (!isEqual(this.props.location, nextProps.location)) {\n      // If no mapSearch url parameter is given, this is original location search\n      const { mapSearch } = parse(nextProps.location.search, {\n        latlng: ['origin'],\n        latlngBounds: ['bounds'],\n      });\n      if (!mapSearch) {\n        this.viewportBounds = null;\n      }\n    }\n\n    if (this.map) {\n      const currentBounds = getMapBounds(this.map);\n\n      // Do not call fitMapToBounds if bounds are the same.\n      // Our bounds are viewport bounds, and fitBounds will try to add margins around those bounds\n      // that would result to zoom-loop (bound change -> fitmap -> bounds change -> ...)\n      if (!isEqual(nextProps.bounds, currentBounds) && !this.viewportBounds) {\n        fitMapToBounds(this.map, nextProps.bounds, { padding: 0, isAutocompleteSearch: true });\n      }\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!this.map && this.state.mapContainer) {\n      this.initializeMap();\n\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    } else if (prevProps.mapComponentRefreshToken !== this.props.mapComponentRefreshToken) {\n      /* Notify parent component that Mapbox map is loaded */\n      this.props.onMapLoad(this.map);\n    }\n  }\n\n  componentWillUnmount() {\n    this.currentInfoCard.markerContainer.removeEventListener(\n      'dblclick',\n      this.handleDoubleClickOnInfoCard\n    );\n    document.removeEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.removeEventListener('gestureend', this.handleMobilePinchZoom, false);\n  }\n\n  onMount(element) {\n    // This prevents pinch zoom to affect whole page on mobile Safari.\n    document.addEventListener('gesturestart', this.handleMobilePinchZoom, false);\n    document.addEventListener('gesturechange', this.handleMobilePinchZoom, false);\n    document.addEventListener('gestureend', this.handleMobilePinchZoom, false);\n\n    this.setState({ mapContainer: element });\n  }\n\n  onMoveend(e) {\n    if (this.map) {\n      // If reusableMapHiddenHandle is given and parent element has that class,\n      // we don't listen moveend events.\n      // This fixes mobile Chrome bug that sends map events to invisible map components.\n      const isHiddenByReusableMap =\n        this.props.reusableMapHiddenHandle &&\n        this.state.mapContainer.parentElement.classList.contains(\n          this.props.reusableMapHiddenHandle\n        );\n      if (!isHiddenByReusableMap) {\n        const viewportMapBounds = getMapBounds(this.map);\n        const viewportMapCenter = getMapCenter(this.map);\n        const viewportBounds = sdkBoundsToFixedCoordinates(\n          viewportMapBounds,\n          BOUNDS_FIXED_PRECISION\n        );\n\n        // ViewportBounds from (previous) rendering differ from viewportBounds currently set to map\n        // I.e. user has changed the map somehow: moved, panned, zoomed, resized\n        const viewportBoundsChanged =\n          this.viewportBounds && !hasSameSDKBounds(this.viewportBounds, viewportBounds);\n\n        this.props.onMapMoveEnd(viewportBoundsChanged, { viewportBounds, viewportMapCenter });\n        this.viewportBounds = viewportBounds;\n      }\n    }\n  }\n\n  initializeMap() {\n    const { offsetHeight, offsetWidth } = this.state.mapContainer;\n    const hasDimensions = offsetHeight > 0 && offsetWidth > 0;\n    if (hasDimensions) {\n      this.map = new window.mapboxgl.Map({\n        container: this.state.mapContainer,\n        style: 'mapbox://styles/mapbox/streets-v10',\n        scrollZoom: false,\n      });\n      window.mapboxMap = this.map;\n\n      var nav = new window.mapboxgl.NavigationControl({ showCompass: false });\n      this.map.addControl(nav, 'top-left');\n\n      this.map.on('moveend', this.onMoveend);\n\n      // Introduce rerendering after map is ready (to include labels),\n      // but keep the map out of state life cycle.\n      this.setState({ isMapReady: true });\n    }\n  }\n\n  handleMobilePinchZoom(e) {\n    e.preventDefault();\n    // A hack to prevent pinch zoom gesture in mobile Safari\n    // Otherwise, pinch zoom would zoom both map and the document.\n    document.body.style.zoom = 0.99;\n  }\n\n  handleDoubleClickOnInfoCard(e) {\n    e.stopPropagation();\n  }\n\n  render() {\n    const {\n      className,\n      listings,\n      activeListingId,\n      infoCardOpen,\n      onListingClicked,\n      onListingInfoCardClicked,\n      createURLToListing,\n      mapComponentRefreshToken,\n    } = this.props;\n\n    if (this.map) {\n      // Create markers out of price labels and grouped labels\n      const labels = priceLabelsInLocations(\n        listings,\n        activeListingId,\n        infoCardOpen,\n        onListingClicked,\n        mapComponentRefreshToken\n      );\n\n      // If map has moved or info card opened, unnecessary markers need to be removed\n      const removableMarkers = differenceBy(this.currentMarkers, labels, 'markerId');\n      removableMarkers.forEach(rm => rm.marker.remove());\n\n      // Helper function to create markers to given container\n      const createMarker = (data, markerContainer) =>\n        new window.mapboxgl.Marker(markerContainer, { anchor: 'bottom' })\n          .setLngLat([data.location.lng, data.location.lat])\n          .addTo(this.map);\n\n      // SearchMapPriceLabel and SearchMapGroupLabel:\n      // create a new marker or use existing one if markerId is among previously rendered markers\n      this.currentMarkers = labels\n        .filter(v => v != null)\n        .map(m => {\n          const existingMarkerId = this.currentMarkers.findIndex(\n            marker => m.markerId === marker.markerId && marker.marker\n          );\n\n          if (existingMarkerId >= 0) {\n            const { marker, markerContainer, ...rest } = this.currentMarkers[existingMarkerId];\n            return { ...rest, ...m, markerContainer, marker };\n          } else {\n            const markerContainer = document.createElement('div');\n            markerContainer.setAttribute('id', m.markerId);\n            markerContainer.classList.add(css.labelContainer);\n            const marker = createMarker(m, markerContainer);\n            return { ...m, markerContainer, marker };\n          }\n        });\n\n      /* Create marker for SearchMapInfoCard component */\n      if (infoCardOpen) {\n        const infoCard = infoCardComponent(\n          infoCardOpen,\n          onListingInfoCardClicked,\n          createURLToListing,\n          mapComponentRefreshToken\n        );\n\n        // marker container and its styles\n        const infoCardContainer = document.createElement('div');\n        infoCardContainer.setAttribute('id', infoCard.markerId);\n        infoCardContainer.classList.add(css.infoCardContainer);\n        infoCardContainer.addEventListener('dblclick', this.handleDoubleClickOnInfoCard, false);\n\n        this.currentInfoCard = {\n          ...infoCard,\n          markerContainer: infoCardContainer,\n          marker: infoCard ? createMarker(infoCard, infoCardContainer) : null,\n        };\n      } else {\n        if (this.currentInfoCard) {\n          this.currentInfoCard.markerContainer.removeEventListener(\n            'dblclick',\n            this.handleDoubleClickOnInfoCard\n          );\n        }\n        this.currentInfoCard = null;\n      }\n    }\n\n    return (\n      <div\n        id=\"map\"\n        ref={this.onMount}\n        className={classNames(className, css.fullArea)}\n        onClick={this.props.onClick}\n      >\n        {this.currentMarkers.map(m => {\n          // Remove existing activeLabel classes and add it only to the correct container\n          m.markerContainer.classList.remove(css.activeLabel);\n          if (activeListingId && activeListingId.uuid === m.componentProps.key) {\n            m.markerContainer.classList.add(css.activeLabel);\n          }\n\n          const isMapReadyForMarkers = this.map && m.markerContainer;\n          // DOM node that should be used as portal's root\n          const portalDOMContainer = isMapReadyForMarkers\n            ? document.getElementById(m.markerContainer.id)\n            : null;\n\n          // Create component portals for correct marker containers\n          if (isMapReadyForMarkers && m.type === 'price') {\n            return ReactDOM.createPortal(\n              <SearchMapPriceLabel {...m.componentProps} />,\n              portalDOMContainer\n            );\n          } else if (isMapReadyForMarkers && m.type === 'group') {\n            return ReactDOM.createPortal(\n              <SearchMapGroupLabel {...m.componentProps} />,\n              portalDOMContainer\n            );\n          }\n          return null;\n        })}\n        {this.state.mapContainer && this.currentInfoCard\n          ? ReactDOM.createPortal(\n              <SearchMapInfoCard {...this.currentInfoCard.componentProps} />,\n              this.currentInfoCard.markerContainer\n            )\n          : null}\n      </div>\n    );\n  }\n}\n\nSearchMapWithMapbox.defaultProps = {\n  center: null,\n  priceLabels: [],\n  infoCard: null,\n  zoom: 11,\n  reusableMapHiddenHandle: null,\n};\n\nSearchMapWithMapbox.propTypes = {\n  center: propTypes.latlng,\n  location: shape({\n    search: string.isRequired,\n  }).isRequired,\n  priceLabels: arrayOf(node),\n  infoCard: node,\n  onClick: func.isRequired,\n  onMapMoveEnd: func.isRequired,\n  onMapLoad: func.isRequired,\n  zoom: number,\n  reusableMapHiddenHandle: string,\n};\n\nexport default SearchMapWithMapbox;\n"]},"metadata":{},"sourceType":"module"}