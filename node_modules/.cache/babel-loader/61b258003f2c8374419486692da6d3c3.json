{"ast":null,"code":"import moment from 'moment';\n/**\n * Input names for the DateRangePicker from react-dates.\n */\n\nexport const START_DATE = 'startDate';\nexport const END_DATE = 'endDate';\n/**\n * Check that the given parameter is a Date object.\n *\n * @param {Date} object that should be a Date.\n *\n * @returns {boolean} true if given parameter is a Date object.\n */\n\nexport const isDate = d => d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\n/**\n * Check if the given parameters represent the same Date value (timestamps are compared)\n *\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\n *\n * @returns {boolean} true if given parameters have the same timestamp.\n */\n\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\n/**\n * Convert date given by API to something meaningful noon on browser's timezone\n * So, what happens is that date given by client\n * (\"Fri Mar 30 2018 12:00:00 GMT-1100 (SST)\" aka \"Fri Mar 30 2018 23:00:00 GMT+0000 (UTC)\")\n * will be read as UTC time. Then API normalizes night/day bookings to\n * start from 00:00 UTC (i.e. discards hours from UTC day).\n * So Api gives 00:00 UTC which (in our example) would be locally\n * \"Thu Mar 29 2018 13:00:00 GMT-1100 (SST)\".\n *\n * The resulting timestamp from API is:\n * localTimestamp.subtract(12h).add(timezoneoffset) (in eg. -23 h)\n *\n * So, this function adds those removed hours back.\n *\n * @param {Date} date is a local date object\n *\n * @returns {Date} date (given by API as UTC 00:00) converted back to local noon.\n */\n\nexport const dateFromAPIToLocalNoon = date => {\n  const timezoneDiffInMinutes = moment(date).utcOffset(); // Example timezone SST:\n  // We get a Fri 00:00 UTC aka \"Thu Mar 29 2018 13:00:00 GMT-1100 (SST)\"\n  // We need to subtract timezone difference (-11h), effectively adding 11h - to get to correct date\n\n  const momentInLocalTimezone = moment(date).subtract(timezoneDiffInMinutes, 'minutes'); // To be on the safe zone with leap seconds and stuff when using day / night picker\n  // we'll add 12 h to get to the noon of day in local timezone.\n\n  return momentInLocalTimezone.add(12, 'hours').toDate();\n};\n/**\n * Convert local date for API.\n * Date given by browser\n * (\"Fri Mar 30 2018 12:00:00 GMT-1100 (SST)\" aka \"Fri Mar 30 2018 23:00:00 GMT+0000 (UTC)\")\n * must be modified so that API will get correct moment also in UTC.\n * We achieve this by adding timezone offset to local date / timestamp.\n *\n * The resulting timestamp for the API is:\n * localTimestamp.add(timezoneoffset)\n * In eg. Fri Mar 30 2018 23:00:00 GMT-1100 (SST) aka \"Fri Mar 30 2018 12:00:00 GMT+0000 (UTC)\"\n *\n * @param {Date} date is a local date object\n *\n * @returns {Date} date (given by API as UTC 00:00) converted back to local noon.\n */\n\nexport const dateFromLocalToAPI = date => {\n  const timezoneDiffInMinutes = moment(date).utcOffset();\n  const momentInLocalTimezone = moment(date).add(timezoneDiffInMinutes, 'minutes');\n  return momentInLocalTimezone.toDate();\n};\n/**\n * Calculate the number of nights between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of nights between the given dates\n */\n\nexport const nightsBetween = (startDate, endDate) => {\n  const nights = moment(endDate).diff(startDate, 'days');\n\n  if (nights < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n\n  return nights;\n};\n/**\n * Calculate the number of days between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period. NOTE: with daily\n * bookings, it is expected that this date is the exclusive end date,\n * i.e. the last day of the booking is the previous date of this end\n * date.\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of days between the given dates\n */\n\nexport const daysBetween = (startDate, endDate) => {\n  const days = moment(endDate).diff(startDate, 'days');\n\n  if (days < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n\n  return days;\n};\n/**\n * Format the given date to month id/string\n *\n * @param {Date} date to be formatted\n *\n * @returns {String} formatted month string\n */\n\nexport const monthIdString = date => moment(date).format('YYYY-MM');\n/**\n * Format the given date to UTC month id/string\n *\n * @param {Date} date to be formatted\n *\n * @returns {String} formatted month string\n */\n\nexport const monthIdStringInUTC = date => moment(date).utc().format('YYYY-MM');\n/**\n * Format the given date\n *\n * @param {Object} intl Intl object from react-intl\n * @param {String} todayString translation for the current day\n * @param {Date} d Date to be formatted\n *\n * @returns {String} formatted date\n */\n\nexport const formatDate = (intl, todayString, d) => {\n  const paramsValid = intl && d instanceof Date && typeof todayString === 'string';\n\n  if (!paramsValid) {\n    throw new Error(\"Invalid params for formatDate: (\".concat(intl, \", \").concat(todayString, \", \").concat(d, \")\"));\n  }\n\n  const now = moment(intl.now());\n  const formattedTime = intl.formatTime(d);\n  let formattedDate;\n\n  if (now.isSame(d, 'day')) {\n    // e.g. \"Today, 9:10pm\"\n    formattedDate = todayString;\n  } else if (now.isSame(d, 'week')) {\n    // e.g. \"Wed, 8:00pm\"\n    formattedDate = intl.formatDate(d, {\n      weekday: 'short'\n    });\n  } else if (now.isSame(d, 'year')) {\n    // e.g. \"Aug 22, 7:40pm\"\n    formattedDate = intl.formatDate(d, {\n      month: 'short',\n      day: 'numeric'\n    });\n  } else {\n    // e.g. \"Jul 17 2016, 6:02pm\"\n    const date = intl.formatDate(d, {\n      month: 'short',\n      day: 'numeric'\n    });\n    const year = intl.formatDate(d, {\n      year: 'numeric'\n    });\n    formattedDate = \"\".concat(date, \" \").concat(year);\n  }\n\n  return \"\".concat(formattedDate, \", \").concat(formattedTime);\n};\n/**\n * Converts string given in ISO8601 format to date object.\n * This is used e.g. when when dates are parsed form urlParams\n *\n * @param {String} dateString in 'YYYY-MM-DD'format\n *\n * @returns {Date} parsed date object\n */\n\nexport const parseDateFromISO8601 = dateString => {\n  return moment(dateString, 'YYYY-MM-DD').toDate();\n};\n/**\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\n * This string is used e.g. in urlParam.\n *\n * @param {Date} date\n *\n * @returns {String} string in 'YYYY-MM-DD'format\n */\n\nexport const stringifyDateToISO8601 = date => {\n  return moment(date).format('YYYY-MM-DD');\n};\n/**\n * Formats string ('YYYY-MM-DD') to UTC format ('0000-00-00T00:00:00.000Z').\n * This is used in search query.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\n\nexport const formatDateStringToUTC = dateString => {\n  return moment.utc(dateString).toDate();\n};\n/**\n * Formats string ('YYYY-MM-DD') to UTC format ('0000-00-00T00:00:00.000Z') and adds one day.\n * This is used as end date of the search query.\n * One day must be added because end of the availability is exclusive in API.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\n\nexport const getExclusiveEndDate = dateString => {\n  return moment.utc(dateString).add(1, 'days').startOf('day').toDate();\n};","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/util/dates.js"],"names":["moment","START_DATE","END_DATE","isDate","d","Object","prototype","toString","call","Number","isNaN","getTime","isSameDate","a","b","dateFromAPIToLocalNoon","date","timezoneDiffInMinutes","utcOffset","momentInLocalTimezone","subtract","add","toDate","dateFromLocalToAPI","nightsBetween","startDate","endDate","nights","diff","Error","daysBetween","days","monthIdString","format","monthIdStringInUTC","utc","formatDate","intl","todayString","paramsValid","Date","now","formattedTime","formatTime","formattedDate","isSame","weekday","month","day","year","parseDateFromISO8601","dateString","stringifyDateToISO8601","formatDateStringToUTC","getExclusiveEndDate","startOf"],"mappings":"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","sourcesContent":["import moment from 'moment';\n\n/**\n * Input names for the DateRangePicker from react-dates.\n */\nexport const START_DATE = 'startDate';\nexport const END_DATE = 'endDate';\n\n/**\n * Check that the given parameter is a Date object.\n *\n * @param {Date} object that should be a Date.\n *\n * @returns {boolean} true if given parameter is a Date object.\n */\nexport const isDate = d =>\n  d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\n\n/**\n * Check if the given parameters represent the same Date value (timestamps are compared)\n *\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\n *\n * @returns {boolean} true if given parameters have the same timestamp.\n */\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\n\n/**\n * Convert date given by API to something meaningful noon on browser's timezone\n * So, what happens is that date given by client\n * (\"Fri Mar 30 2018 12:00:00 GMT-1100 (SST)\" aka \"Fri Mar 30 2018 23:00:00 GMT+0000 (UTC)\")\n * will be read as UTC time. Then API normalizes night/day bookings to\n * start from 00:00 UTC (i.e. discards hours from UTC day).\n * So Api gives 00:00 UTC which (in our example) would be locally\n * \"Thu Mar 29 2018 13:00:00 GMT-1100 (SST)\".\n *\n * The resulting timestamp from API is:\n * localTimestamp.subtract(12h).add(timezoneoffset) (in eg. -23 h)\n *\n * So, this function adds those removed hours back.\n *\n * @param {Date} date is a local date object\n *\n * @returns {Date} date (given by API as UTC 00:00) converted back to local noon.\n */\nexport const dateFromAPIToLocalNoon = date => {\n  const timezoneDiffInMinutes = moment(date).utcOffset();\n  // Example timezone SST:\n  // We get a Fri 00:00 UTC aka \"Thu Mar 29 2018 13:00:00 GMT-1100 (SST)\"\n  // We need to subtract timezone difference (-11h), effectively adding 11h - to get to correct date\n  const momentInLocalTimezone = moment(date).subtract(timezoneDiffInMinutes, 'minutes');\n  // To be on the safe zone with leap seconds and stuff when using day / night picker\n  // we'll add 12 h to get to the noon of day in local timezone.\n  return momentInLocalTimezone.add(12, 'hours').toDate();\n};\n\n/**\n * Convert local date for API.\n * Date given by browser\n * (\"Fri Mar 30 2018 12:00:00 GMT-1100 (SST)\" aka \"Fri Mar 30 2018 23:00:00 GMT+0000 (UTC)\")\n * must be modified so that API will get correct moment also in UTC.\n * We achieve this by adding timezone offset to local date / timestamp.\n *\n * The resulting timestamp for the API is:\n * localTimestamp.add(timezoneoffset)\n * In eg. Fri Mar 30 2018 23:00:00 GMT-1100 (SST) aka \"Fri Mar 30 2018 12:00:00 GMT+0000 (UTC)\"\n *\n * @param {Date} date is a local date object\n *\n * @returns {Date} date (given by API as UTC 00:00) converted back to local noon.\n */\nexport const dateFromLocalToAPI = date => {\n  const timezoneDiffInMinutes = moment(date).utcOffset();\n  const momentInLocalTimezone = moment(date).add(timezoneDiffInMinutes, 'minutes');\n\n  return momentInLocalTimezone.toDate();\n};\n\n/**\n * Calculate the number of nights between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of nights between the given dates\n */\nexport const nightsBetween = (startDate, endDate) => {\n  const nights = moment(endDate).diff(startDate, 'days');\n  if (nights < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n  return nights;\n};\n\n/**\n * Calculate the number of days between the given dates\n *\n * @param {Date} startDate start of the time period\n * @param {Date} endDate end of the time period. NOTE: with daily\n * bookings, it is expected that this date is the exclusive end date,\n * i.e. the last day of the booking is the previous date of this end\n * date.\n *\n * @throws Will throw if the end date is before the start date\n * @returns {Number} number of days between the given dates\n */\nexport const daysBetween = (startDate, endDate) => {\n  const days = moment(endDate).diff(startDate, 'days');\n  if (days < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n  return days;\n};\n\n/**\n * Format the given date to month id/string\n *\n * @param {Date} date to be formatted\n *\n * @returns {String} formatted month string\n */\nexport const monthIdString = date => moment(date).format('YYYY-MM');\n\n/**\n * Format the given date to UTC month id/string\n *\n * @param {Date} date to be formatted\n *\n * @returns {String} formatted month string\n */\nexport const monthIdStringInUTC = date =>\n  moment(date)\n    .utc()\n    .format('YYYY-MM');\n\n/**\n * Format the given date\n *\n * @param {Object} intl Intl object from react-intl\n * @param {String} todayString translation for the current day\n * @param {Date} d Date to be formatted\n *\n * @returns {String} formatted date\n */\nexport const formatDate = (intl, todayString, d) => {\n  const paramsValid = intl && d instanceof Date && typeof todayString === 'string';\n  if (!paramsValid) {\n    throw new Error(`Invalid params for formatDate: (${intl}, ${todayString}, ${d})`);\n  }\n  const now = moment(intl.now());\n  const formattedTime = intl.formatTime(d);\n  let formattedDate;\n\n  if (now.isSame(d, 'day')) {\n    // e.g. \"Today, 9:10pm\"\n    formattedDate = todayString;\n  } else if (now.isSame(d, 'week')) {\n    // e.g. \"Wed, 8:00pm\"\n    formattedDate = intl.formatDate(d, {\n      weekday: 'short',\n    });\n  } else if (now.isSame(d, 'year')) {\n    // e.g. \"Aug 22, 7:40pm\"\n    formattedDate = intl.formatDate(d, {\n      month: 'short',\n      day: 'numeric',\n    });\n  } else {\n    // e.g. \"Jul 17 2016, 6:02pm\"\n    const date = intl.formatDate(d, {\n      month: 'short',\n      day: 'numeric',\n    });\n    const year = intl.formatDate(d, {\n      year: 'numeric',\n    });\n    formattedDate = `${date} ${year}`;\n  }\n\n  return `${formattedDate}, ${formattedTime}`;\n};\n\n/**\n * Converts string given in ISO8601 format to date object.\n * This is used e.g. when when dates are parsed form urlParams\n *\n * @param {String} dateString in 'YYYY-MM-DD'format\n *\n * @returns {Date} parsed date object\n */\nexport const parseDateFromISO8601 = dateString => {\n  return moment(dateString, 'YYYY-MM-DD').toDate();\n};\n\n/**\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\n * This string is used e.g. in urlParam.\n *\n * @param {Date} date\n *\n * @returns {String} string in 'YYYY-MM-DD'format\n */\n\nexport const stringifyDateToISO8601 = date => {\n  return moment(date).format('YYYY-MM-DD');\n};\n\n/**\n * Formats string ('YYYY-MM-DD') to UTC format ('0000-00-00T00:00:00.000Z').\n * This is used in search query.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\n\nexport const formatDateStringToUTC = dateString => {\n  return moment.utc(dateString).toDate();\n};\n\n/**\n * Formats string ('YYYY-MM-DD') to UTC format ('0000-00-00T00:00:00.000Z') and adds one day.\n * This is used as end date of the search query.\n * One day must be added because end of the availability is exclusive in API.\n *\n * @param {String} string in 'YYYY-MM-DD'format\n *\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\n */\n\nexport const getExclusiveEndDate = dateString => {\n  return moment\n    .utc(dateString)\n    .add(1, 'days')\n    .startOf('day')\n    .toDate();\n};\n"]},"metadata":{},"sourceType":"module"}