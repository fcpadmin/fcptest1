{"ast":null,"code":"import _objectSpread from \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nvar _jsxFileName = \"/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/components/LocationAutocompleteInput/LocationAutocompleteInputImpl.js\";\nimport React, { Component } from 'react';\nimport { any, arrayOf, bool, func, number, shape, string, oneOfType, object } from 'prop-types';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport debounce from 'lodash/debounce';\nimport { IconSpinner } from '../../components';\nimport { propTypes } from '../../util/types';\nimport config from '../../config';\nimport IconHourGlass from './IconHourGlass';\nimport IconCurrentLocation from './IconCurrentLocation';\nimport Geocoder, { GeocoderAttribution, CURRENT_LOCATION_ID } from './GeocoderMapbox'; // import Geocoder, { GeocoderAttribution, CURRENT_LOCATION_ID } from './GeocoderGoogleMaps';\n\nimport css from './LocationAutocompleteInput.css'; // A list of default predictions that can be shown when the user\n// focuses on the autocomplete input without typing a search. This can\n// be used to reduce typing and Geocoding API calls for common\n// searches.\n\nexport const defaultPredictions = (config.maps.search.suggestCurrentLocation ? [{\n  id: CURRENT_LOCATION_ID,\n  predictionPlace: {}\n}] : []).concat(config.maps.search.defaults);\nconst DEBOUNCE_WAIT_TIME = 300;\nconst DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES = 1000;\nconst KEY_CODE_ARROW_UP = 38;\nconst KEY_CODE_ARROW_DOWN = 40;\nconst KEY_CODE_ENTER = 13;\nconst KEY_CODE_TAB = 9;\nconst KEY_CODE_ESC = 27;\nconst DIRECTION_UP = 'up';\nconst DIRECTION_DOWN = 'down';\nconst TOUCH_TAP_RADIUS = 5; // Movement within 5px from touch start is considered a tap\n// Touch devices need to be able to distinguish touches for scrolling and touches to tap\n\nconst getTouchCoordinates = nativeEvent => {\n  const touch = nativeEvent && nativeEvent.changedTouches ? nativeEvent.changedTouches[0] : null;\n  return touch ? {\n    x: touch.screenX,\n    y: touch.screenY\n  } : null;\n}; // Renders the autocompletion prediction results in a list\n\n\nconst LocationPredictionsList = props => {\n  const rootClassName = props.rootClassName,\n        className = props.className,\n        attributionClassName = props.attributionClassName,\n        predictions = props.predictions,\n        geocoder = props.geocoder,\n        highlightedIndex = props.highlightedIndex,\n        onSelectStart = props.onSelectStart,\n        onSelectMove = props.onSelectMove,\n        onSelectEnd = props.onSelectEnd;\n\n  if (predictions.length === 0) {\n    return null;\n  }\n  /* eslint-disable jsx-a11y/no-static-element-interactions */\n\n\n  const item = (prediction, index) => {\n    const isHighlighted = index === highlightedIndex;\n    const predictionId = geocoder.getPredictionId(prediction);\n    return React.createElement(\"li\", {\n      className: isHighlighted ? css.highlighted : null,\n      key: predictionId,\n      onTouchStart: e => {\n        e.preventDefault();\n        onSelectStart(getTouchCoordinates(e.nativeEvent));\n      },\n      onMouseDown: e => {\n        e.preventDefault();\n        onSelectStart();\n      },\n      onTouchMove: e => {\n        e.preventDefault();\n        onSelectMove(getTouchCoordinates(e.nativeEvent));\n      },\n      onTouchEnd: e => {\n        e.preventDefault();\n        onSelectEnd(prediction);\n      },\n      onMouseUp: e => {\n        e.preventDefault();\n        onSelectEnd(prediction);\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66\n      },\n      __self: this\n    }, predictionId === CURRENT_LOCATION_ID ? React.createElement(\"span\", {\n      className: css.currentLocation,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 91\n      },\n      __self: this\n    }, React.createElement(IconCurrentLocation, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 92\n      },\n      __self: this\n    }), React.createElement(FormattedMessage, {\n      id: \"LocationAutocompleteInput.currentLocation\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 93\n      },\n      __self: this\n    })) : geocoder.getPredictionAddress(prediction));\n  };\n  /* eslint-enable jsx-a11y/no-static-element-interactions */\n\n\n  const classes = classNames(rootClassName || css.predictionsRoot, className);\n  return React.createElement(\"div\", {\n    className: classes,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106\n    },\n    __self: this\n  }, React.createElement(\"ul\", {\n    className: css.predictions,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107\n    },\n    __self: this\n  }, predictions.map(item)), React.createElement(GeocoderAttribution, {\n    className: attributionClassName,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108\n    },\n    __self: this\n  }));\n};\n\nLocationPredictionsList.defaultProps = {\n  rootClassName: null,\n  className: null,\n  attributionClassName: null,\n  highlightedIndex: null\n};\nLocationPredictionsList.propTypes = {\n  rootClassName: string,\n  className: string,\n  attributionClassName: string,\n  predictions: arrayOf(object).isRequired,\n  geocoder: object.isRequired,\n  highlightedIndex: number,\n  onSelectStart: func.isRequired,\n  onSelectMove: func.isRequired,\n  onSelectEnd: func.isRequired\n}; // Get the current value with defaults from the given\n// LocationAutocompleteInput props.\n\nconst currentValue = props => {\n  const value = props.input.value || {};\n  const _value$search = value.search,\n        search = _value$search === void 0 ? '' : _value$search,\n        _value$predictions = value.predictions,\n        predictions = _value$predictions === void 0 ? [] : _value$predictions,\n        _value$selectedPlace = value.selectedPlace,\n        selectedPlace = _value$selectedPlace === void 0 ? null : _value$selectedPlace;\n  return {\n    search,\n    predictions,\n    selectedPlace\n  };\n};\n/*\n  Location auto completion input component\n\n  This component can work as the `component` prop to Final Form's\n  <Field /> component. It takes a custom input value shape, and\n  controls the onChange callback that is called with the input value.\n\n  The component works by listening to the underlying input component\n  and calling a Geocoder implementation for predictions. When the\n  predictions arrive, those are passed to Final Form in the onChange\n  callback.\n\n  See the LocationAutocompleteInput.example.js file for a usage\n  example within a form.\n*/\n\n\nclass LocationAutocompleteInputImpl extends Component {\n  constructor(props) {\n    super(props);\n    this._isMounted = false;\n    this.state = {\n      inputHasFocus: false,\n      selectionInProgress: false,\n      touchStartedFrom: null,\n      highlightedIndex: -1,\n      // -1 means no highlight\n      fetchingPlaceDetails: false,\n      fetchingPredictions: false\n    }; // Ref to the input element.\n\n    this.input = null;\n    this.shortQueryTimeout = null;\n    this.getGeocoder = this.getGeocoder.bind(this);\n    this.currentPredictions = this.currentPredictions.bind(this);\n    this.changeHighlight = this.changeHighlight.bind(this);\n    this.selectPrediction = this.selectPrediction.bind(this);\n    this.selectItemIfNoneSelected = this.selectItemIfNoneSelected.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onChange = this.onChange.bind(this);\n    this.handleOnBlur = this.handleOnBlur.bind(this);\n    this.handlePredictionsSelectStart = this.handlePredictionsSelectStart.bind(this);\n    this.handlePredictionsSelectMove = this.handlePredictionsSelectMove.bind(this);\n    this.handlePredictionsSelectEnd = this.handlePredictionsSelectEnd.bind(this);\n    this.finalizeSelection = this.finalizeSelection.bind(this); // Debounce the method to avoid calling the API too many times\n    // when the user is typing fast.\n\n    this.predict = debounce(this.predict.bind(this), DEBOUNCE_WAIT_TIME, {\n      leading: true\n    });\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    window.clearTimeout(this.shortQueryTimeout);\n    this._isMounted = false;\n  }\n\n  getGeocoder() {\n    // Create the Geocoder as late as possible only when it is needed.\n    if (!this._geocoder) {\n      this._geocoder = new Geocoder();\n    }\n\n    return this._geocoder;\n  }\n\n  currentPredictions() {\n    const _currentValue = currentValue(this.props),\n          search = _currentValue.search,\n          fetchedPredictions = _currentValue.predictions;\n\n    const useDefaultPredictions = this.props.useDefaultPredictions;\n    const hasFetchedPredictions = fetchedPredictions && fetchedPredictions.length > 0;\n    const showDefaultPredictions = !search && !hasFetchedPredictions && useDefaultPredictions;\n    return showDefaultPredictions ? defaultPredictions : fetchedPredictions;\n  } // Interpret input key event\n\n\n  onKeyDown(e) {\n    if (e.keyCode === KEY_CODE_ARROW_UP) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_UP);\n    } else if (e.keyCode === KEY_CODE_ARROW_DOWN) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_DOWN);\n    } else if (e.keyCode === KEY_CODE_ENTER) {\n      const _currentValue2 = currentValue(this.props),\n            selectedPlace = _currentValue2.selectedPlace;\n\n      if (!selectedPlace) {\n        // Prevent form submit, try to select value instead.\n        e.preventDefault();\n        e.stopPropagation();\n        this.selectItemIfNoneSelected();\n        this.input.blur();\n      }\n    } else if (e.keyCode === KEY_CODE_TAB) {\n      this.selectItemIfNoneSelected();\n      this.input.blur();\n    } else if (e.keyCode === KEY_CODE_ESC && this.input) {\n      this.input.blur();\n    }\n  } // Handle input text change, fetch predictions if the value isn't empty\n\n\n  onChange(e) {\n    const onChange = this.props.input.onChange;\n    const predictions = this.currentPredictions();\n    const newValue = e.target.value; // Clear the current values since the input content is changed\n\n    onChange({\n      search: newValue,\n      predictions: newValue ? predictions : [],\n      selectedPlace: null\n    }); // Clear highlighted prediction since the input value changed and\n    // results will change as well\n\n    this.setState({\n      highlightedIndex: -1\n    });\n\n    if (!newValue) {\n      // No need to fetch predictions on empty input\n      return;\n    }\n\n    if (newValue.length >= 3) {\n      if (this.shortQueryTimeout) {\n        window.clearTimeout(this.shortQueryTimeout);\n      }\n\n      this.predict(newValue);\n    } else {\n      this.shortQueryTimeout = window.setTimeout(() => {\n        this.predict(newValue);\n      }, DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES);\n    }\n  } // Change the currently highlighted item by calculating the new\n  // index from the current state and the given direction number\n  // (DIRECTION_UP or DIRECTION_DOWN)\n\n\n  changeHighlight(direction) {\n    this.setState((prevState, props) => {\n      const predictions = this.currentPredictions();\n      const currentIndex = prevState.highlightedIndex;\n      let index = currentIndex;\n\n      if (direction === DIRECTION_UP) {\n        // Keep the first position if already highlighted\n        index = currentIndex === 0 ? 0 : currentIndex - 1;\n      } else if (direction === DIRECTION_DOWN) {\n        index = currentIndex + 1;\n      } // Check that the index is within the bounds\n\n\n      if (index < 0) {\n        index = -1;\n      } else if (index >= predictions.length) {\n        index = predictions.length - 1;\n      }\n\n      return {\n        highlightedIndex: index\n      };\n    });\n  } // Select the prediction in the given item. This will fetch/read the\n  // place details and set it as the selected place.\n\n\n  selectPrediction(prediction) {\n    this.props.input.onChange(_objectSpread({}, this.props.input, {\n      selectedPlace: null\n    }));\n    this.setState({\n      fetchingPlaceDetails: true\n    });\n    this.getGeocoder().getPlaceDetails(prediction).then(place => {\n      if (!this._isMounted) {\n        // Ignore if component already unmounted\n        return;\n      }\n\n      this.setState({\n        fetchingPlaceDetails: false\n      });\n      this.props.input.onChange({\n        search: place.address,\n        predictions: [],\n        selectedPlace: place\n      });\n    }).catch(e => {\n      this.setState({\n        fetchingPlaceDetails: false\n      }); // eslint-disable-next-line no-console\n\n      console.error(e);\n      this.props.input.onChange(_objectSpread({}, this.props.input.value, {\n        selectedPlace: null\n      }));\n    });\n  }\n\n  selectItemIfNoneSelected() {\n    if (this.state.fetchingPredictions) {\n      // No need to select anything since prediction fetch is still going on\n      return;\n    }\n\n    const _currentValue3 = currentValue(this.props),\n          search = _currentValue3.search,\n          selectedPlace = _currentValue3.selectedPlace;\n\n    const predictions = this.currentPredictions();\n\n    if (!selectedPlace) {\n      if (predictions && predictions.length > 0) {\n        const index = this.state.highlightedIndex !== -1 ? this.state.highlightedIndex : 0;\n        this.selectPrediction(predictions[index]);\n      } else {\n        this.predict(search);\n      }\n    }\n  }\n\n  predict(search) {\n    const onChange = this.props.input.onChange;\n    this.setState({\n      fetchingPredictions: true\n    });\n    return this.getGeocoder().getPlacePredictions(search).then(results => {\n      const _currentValue4 = currentValue(this.props),\n            currentSearch = _currentValue4.search;\n\n      this.setState({\n        fetchingPredictions: false\n      }); // If the earlier predictions arrive when the user has already\n      // changed the search term, ignore and wait until the latest\n      // predictions arrive. Without this logic, results for earlier\n      // requests would override whatever the user had typed since.\n      //\n      // This is essentially the same as switchLatest in RxJS or\n      // takeLatest in Redux Saga, without canceling the earlier\n      // requests.\n\n      if (results.search === currentSearch) {\n        onChange({\n          search: results.search,\n          predictions: results.predictions,\n          selectedPlace: null\n        });\n      }\n    }).catch(e => {\n      this.setState({\n        fetchingPredictions: false\n      }); // eslint-disable-next-line no-console\n\n      console.error(e);\n      const value = currentValue(this.props);\n      onChange(_objectSpread({}, value, {\n        selectedPlace: null\n      }));\n    });\n  }\n\n  finalizeSelection() {\n    this.setState({\n      inputHasFocus: false,\n      highlightedIndex: -1\n    });\n    this.props.input.onBlur(currentValue(this.props));\n  }\n\n  handleOnBlur() {\n    if (this.props.closeOnBlur && !this.state.selectionInProgress) {\n      this.finalizeSelection();\n    }\n  }\n\n  handlePredictionsSelectStart(touchCoordinates) {\n    this.setState({\n      selectionInProgress: true,\n      touchStartedFrom: touchCoordinates,\n      isSwipe: false\n    });\n  }\n\n  handlePredictionsSelectMove(touchCoordinates) {\n    this.setState(prevState => {\n      const touchStartedFrom = prevState.touchStartedFrom;\n      const isTouchAction = !!touchStartedFrom;\n      const isSwipe = isTouchAction ? Math.abs(touchStartedFrom.y - touchCoordinates.y) > TOUCH_TAP_RADIUS : false;\n      return {\n        selectionInProgress: false,\n        isSwipe\n      };\n    });\n  }\n\n  handlePredictionsSelectEnd(prediction) {\n    let selectAndFinalize = false;\n    this.setState(prevState => {\n      if (!prevState.isSwipe) {\n        selectAndFinalize = true;\n      }\n\n      return {\n        selectionInProgress: false,\n        touchStartedFrom: null,\n        isSwipe: false\n      };\n    }, () => {\n      if (selectAndFinalize) {\n        this.selectPrediction(prediction);\n        this.finalizeSelection();\n      }\n    });\n  }\n\n  render() {\n    const _this$props = this.props,\n          autoFocus = _this$props.autoFocus,\n          rootClassName = _this$props.rootClassName,\n          className = _this$props.className,\n          iconClassName = _this$props.iconClassName,\n          inputClassName = _this$props.inputClassName,\n          predictionsClassName = _this$props.predictionsClassName,\n          predictionsAttributionClassName = _this$props.predictionsAttributionClassName,\n          validClassName = _this$props.validClassName,\n          placeholder = _this$props.placeholder,\n          input = _this$props.input,\n          meta = _this$props.meta,\n          inputRef = _this$props.inputRef;\n    const name = input.name,\n          onFocus = input.onFocus;\n\n    const _currentValue5 = currentValue(this.props),\n          search = _currentValue5.search;\n\n    const _ref = meta || {},\n          touched = _ref.touched,\n          valid = _ref.valid;\n\n    const isValid = valid && touched;\n    const predictions = this.currentPredictions();\n\n    const handleOnFocus = e => {\n      this.setState({\n        inputHasFocus: true\n      });\n      onFocus(e);\n    };\n\n    const rootClass = classNames(rootClassName || css.root, className);\n    const iconClass = classNames(iconClassName || css.icon);\n    const inputClass = classNames(inputClassName || css.input, {\n      [validClassName]: isValid\n    });\n    const predictionsClass = classNames(predictionsClassName); // Only render predictions when the input has focus. For\n    // development and easier workflow with the browser devtools, you\n    // might want to hardcode this to `true`. Otherwise the dropdown\n    // list will disappear.\n\n    const renderPredictions = this.state.inputHasFocus;\n    return React.createElement(\"div\", {\n      className: rootClass,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 483\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: iconClass,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 484\n      },\n      __self: this\n    }, this.state.fetchingPlaceDetails ? React.createElement(IconSpinner, {\n      className: css.iconSpinner,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 486\n      },\n      __self: this\n    }) : React.createElement(IconHourGlass, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 488\n      },\n      __self: this\n    })), React.createElement(\"input\", {\n      className: inputClass,\n      type: \"search\",\n      autoComplete: \"off\",\n      autoFocus: autoFocus,\n      placeholder: placeholder,\n      name: name,\n      value: search,\n      disabled: this.state.fetchingPlaceDetails,\n      onFocus: handleOnFocus,\n      onBlur: this.handleOnBlur,\n      onChange: this.onChange,\n      onKeyDown: this.onKeyDown,\n      ref: node => {\n        this.input = node;\n\n        if (inputRef) {\n          inputRef(node);\n        }\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 491\n      },\n      __self: this\n    }), renderPredictions ? React.createElement(LocationPredictionsList, {\n      rootClassName: predictionsClass,\n      attributionClassName: predictionsAttributionClassName,\n      predictions: predictions,\n      geocoder: this.getGeocoder(),\n      highlightedIndex: this.state.highlightedIndex,\n      onSelectStart: this.handlePredictionsSelectStart,\n      onSelectMove: this.handlePredictionsSelectMove,\n      onSelectEnd: this.handlePredictionsSelectEnd,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 512\n      },\n      __self: this\n    }) : null);\n  }\n\n}\n\nLocationAutocompleteInputImpl.defaultProps = {\n  autoFocus: false,\n  closeOnBlur: true,\n  rootClassName: null,\n  className: null,\n  iconClassName: null,\n  inputClassName: null,\n  predictionsClassName: null,\n  predictionsAttributionClassName: null,\n  validClassName: null,\n  placeholder: '',\n  useDefaultPredictions: true,\n  meta: null,\n  inputRef: null\n};\nLocationAutocompleteInputImpl.propTypes = {\n  autoFocus: bool,\n  rootClassName: string,\n  className: string,\n  closeOnBlur: bool,\n  iconClassName: string,\n  inputClassName: string,\n  predictionsClassName: string,\n  predictionsAttributionClassName: string,\n  validClassName: string,\n  placeholder: string,\n  useDefaultPredictions: bool,\n  input: shape({\n    name: string.isRequired,\n    value: oneOfType([shape({\n      search: string,\n      predictions: any,\n      selectedPlace: propTypes.place\n    }), string]),\n    onChange: func.isRequired,\n    onFocus: func.isRequired,\n    onBlur: func.isRequired\n  }).isRequired,\n  meta: shape({\n    valid: bool.isRequired,\n    touched: bool.isRequired\n  }),\n  inputRef: func\n};\nexport default LocationAutocompleteInputImpl;","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/components/LocationAutocompleteInput/LocationAutocompleteInputImpl.js"],"names":["React","Component","any","arrayOf","bool","func","number","shape","string","oneOfType","object","FormattedMessage","classNames","debounce","IconSpinner","propTypes","config","IconHourGlass","IconCurrentLocation","Geocoder","GeocoderAttribution","CURRENT_LOCATION_ID","css","defaultPredictions","maps","search","suggestCurrentLocation","id","predictionPlace","concat","defaults","DEBOUNCE_WAIT_TIME","DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES","KEY_CODE_ARROW_UP","KEY_CODE_ARROW_DOWN","KEY_CODE_ENTER","KEY_CODE_TAB","KEY_CODE_ESC","DIRECTION_UP","DIRECTION_DOWN","TOUCH_TAP_RADIUS","getTouchCoordinates","nativeEvent","touch","changedTouches","x","screenX","y","screenY","LocationPredictionsList","props","rootClassName","className","attributionClassName","predictions","geocoder","highlightedIndex","onSelectStart","onSelectMove","onSelectEnd","length","item","prediction","index","isHighlighted","predictionId","getPredictionId","highlighted","e","preventDefault","currentLocation","getPredictionAddress","classes","predictionsRoot","map","defaultProps","isRequired","currentValue","value","input","selectedPlace","LocationAutocompleteInputImpl","constructor","_isMounted","state","inputHasFocus","selectionInProgress","touchStartedFrom","fetchingPlaceDetails","fetchingPredictions","shortQueryTimeout","getGeocoder","bind","currentPredictions","changeHighlight","selectPrediction","selectItemIfNoneSelected","onKeyDown","onChange","handleOnBlur","handlePredictionsSelectStart","handlePredictionsSelectMove","handlePredictionsSelectEnd","finalizeSelection","predict","leading","componentDidMount","componentWillUnmount","window","clearTimeout","_geocoder","fetchedPredictions","useDefaultPredictions","hasFetchedPredictions","showDefaultPredictions","keyCode","stopPropagation","blur","newValue","target","setState","setTimeout","direction","prevState","currentIndex","getPlaceDetails","then","place","address","catch","console","error","getPlacePredictions","results","currentSearch","onBlur","closeOnBlur","touchCoordinates","isSwipe","isTouchAction","Math","abs","selectAndFinalize","render","autoFocus","iconClassName","inputClassName","predictionsClassName","predictionsAttributionClassName","validClassName","placeholder","meta","inputRef","name","onFocus","touched","valid","isValid","handleOnFocus","rootClass","root","iconClass","icon","inputClass","predictionsClass","renderPredictions","iconSpinner","node"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { any, arrayOf, bool, func, number, shape, string, oneOfType, object } from 'prop-types';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport debounce from 'lodash/debounce';\nimport { IconSpinner } from '../../components';\nimport { propTypes } from '../../util/types';\nimport config from '../../config';\n\nimport IconHourGlass from './IconHourGlass';\nimport IconCurrentLocation from './IconCurrentLocation';\nimport Geocoder, { GeocoderAttribution, CURRENT_LOCATION_ID } from './GeocoderMapbox';\n// import Geocoder, { GeocoderAttribution, CURRENT_LOCATION_ID } from './GeocoderGoogleMaps';\n\nimport css from './LocationAutocompleteInput.css';\n\n// A list of default predictions that can be shown when the user\n// focuses on the autocomplete input without typing a search. This can\n// be used to reduce typing and Geocoding API calls for common\n// searches.\nexport const defaultPredictions = (config.maps.search.suggestCurrentLocation\n  ? [{ id: CURRENT_LOCATION_ID, predictionPlace: {} }]\n  : []\n).concat(config.maps.search.defaults);\n\nconst DEBOUNCE_WAIT_TIME = 300;\nconst DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES = 1000;\nconst KEY_CODE_ARROW_UP = 38;\nconst KEY_CODE_ARROW_DOWN = 40;\nconst KEY_CODE_ENTER = 13;\nconst KEY_CODE_TAB = 9;\nconst KEY_CODE_ESC = 27;\nconst DIRECTION_UP = 'up';\nconst DIRECTION_DOWN = 'down';\nconst TOUCH_TAP_RADIUS = 5; // Movement within 5px from touch start is considered a tap\n\n// Touch devices need to be able to distinguish touches for scrolling and touches to tap\nconst getTouchCoordinates = nativeEvent => {\n  const touch = nativeEvent && nativeEvent.changedTouches ? nativeEvent.changedTouches[0] : null;\n  return touch ? { x: touch.screenX, y: touch.screenY } : null;\n};\n\n// Renders the autocompletion prediction results in a list\nconst LocationPredictionsList = props => {\n  const {\n    rootClassName,\n    className,\n    attributionClassName,\n    predictions,\n    geocoder,\n    highlightedIndex,\n    onSelectStart,\n    onSelectMove,\n    onSelectEnd,\n  } = props;\n  if (predictions.length === 0) {\n    return null;\n  }\n\n  /* eslint-disable jsx-a11y/no-static-element-interactions */\n  const item = (prediction, index) => {\n    const isHighlighted = index === highlightedIndex;\n    const predictionId = geocoder.getPredictionId(prediction);\n\n    return (\n      <li\n        className={isHighlighted ? css.highlighted : null}\n        key={predictionId}\n        onTouchStart={e => {\n          e.preventDefault();\n          onSelectStart(getTouchCoordinates(e.nativeEvent));\n        }}\n        onMouseDown={e => {\n          e.preventDefault();\n          onSelectStart();\n        }}\n        onTouchMove={e => {\n          e.preventDefault();\n          onSelectMove(getTouchCoordinates(e.nativeEvent));\n        }}\n        onTouchEnd={e => {\n          e.preventDefault();\n          onSelectEnd(prediction);\n        }}\n        onMouseUp={e => {\n          e.preventDefault();\n          onSelectEnd(prediction);\n        }}\n      >\n        {predictionId === CURRENT_LOCATION_ID ? (\n          <span className={css.currentLocation}>\n            <IconCurrentLocation />\n            <FormattedMessage id=\"LocationAutocompleteInput.currentLocation\" />\n          </span>\n        ) : (\n          geocoder.getPredictionAddress(prediction)\n        )}\n      </li>\n    );\n  };\n  /* eslint-enable jsx-a11y/no-static-element-interactions */\n\n  const classes = classNames(rootClassName || css.predictionsRoot, className);\n\n  return (\n    <div className={classes}>\n      <ul className={css.predictions}>{predictions.map(item)}</ul>\n      <GeocoderAttribution className={attributionClassName} />\n    </div>\n  );\n};\n\nLocationPredictionsList.defaultProps = {\n  rootClassName: null,\n  className: null,\n  attributionClassName: null,\n  highlightedIndex: null,\n};\n\nLocationPredictionsList.propTypes = {\n  rootClassName: string,\n  className: string,\n  attributionClassName: string,\n  predictions: arrayOf(object).isRequired,\n  geocoder: object.isRequired,\n  highlightedIndex: number,\n  onSelectStart: func.isRequired,\n  onSelectMove: func.isRequired,\n  onSelectEnd: func.isRequired,\n};\n\n// Get the current value with defaults from the given\n// LocationAutocompleteInput props.\nconst currentValue = props => {\n  const value = props.input.value || {};\n  const { search = '', predictions = [], selectedPlace = null } = value;\n  return { search, predictions, selectedPlace };\n};\n\n/*\n  Location auto completion input component\n\n  This component can work as the `component` prop to Final Form's\n  <Field /> component. It takes a custom input value shape, and\n  controls the onChange callback that is called with the input value.\n\n  The component works by listening to the underlying input component\n  and calling a Geocoder implementation for predictions. When the\n  predictions arrive, those are passed to Final Form in the onChange\n  callback.\n\n  See the LocationAutocompleteInput.example.js file for a usage\n  example within a form.\n*/\nclass LocationAutocompleteInputImpl extends Component {\n  constructor(props) {\n    super(props);\n\n    this._isMounted = false;\n\n    this.state = {\n      inputHasFocus: false,\n      selectionInProgress: false,\n      touchStartedFrom: null,\n      highlightedIndex: -1, // -1 means no highlight\n      fetchingPlaceDetails: false,\n      fetchingPredictions: false,\n    };\n\n    // Ref to the input element.\n    this.input = null;\n    this.shortQueryTimeout = null;\n\n    this.getGeocoder = this.getGeocoder.bind(this);\n    this.currentPredictions = this.currentPredictions.bind(this);\n    this.changeHighlight = this.changeHighlight.bind(this);\n    this.selectPrediction = this.selectPrediction.bind(this);\n    this.selectItemIfNoneSelected = this.selectItemIfNoneSelected.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onChange = this.onChange.bind(this);\n    this.handleOnBlur = this.handleOnBlur.bind(this);\n    this.handlePredictionsSelectStart = this.handlePredictionsSelectStart.bind(this);\n    this.handlePredictionsSelectMove = this.handlePredictionsSelectMove.bind(this);\n    this.handlePredictionsSelectEnd = this.handlePredictionsSelectEnd.bind(this);\n    this.finalizeSelection = this.finalizeSelection.bind(this);\n\n    // Debounce the method to avoid calling the API too many times\n    // when the user is typing fast.\n    this.predict = debounce(this.predict.bind(this), DEBOUNCE_WAIT_TIME, { leading: true });\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    window.clearTimeout(this.shortQueryTimeout);\n    this._isMounted = false;\n  }\n\n  getGeocoder() {\n    // Create the Geocoder as late as possible only when it is needed.\n    if (!this._geocoder) {\n      this._geocoder = new Geocoder();\n    }\n    return this._geocoder;\n  }\n\n  currentPredictions() {\n    const { search, predictions: fetchedPredictions } = currentValue(this.props);\n    const { useDefaultPredictions } = this.props;\n    const hasFetchedPredictions = fetchedPredictions && fetchedPredictions.length > 0;\n    const showDefaultPredictions = !search && !hasFetchedPredictions && useDefaultPredictions;\n\n    return showDefaultPredictions ? defaultPredictions : fetchedPredictions;\n  }\n\n  // Interpret input key event\n  onKeyDown(e) {\n    if (e.keyCode === KEY_CODE_ARROW_UP) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_UP);\n    } else if (e.keyCode === KEY_CODE_ARROW_DOWN) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_DOWN);\n    } else if (e.keyCode === KEY_CODE_ENTER) {\n      const { selectedPlace } = currentValue(this.props);\n\n      if (!selectedPlace) {\n        // Prevent form submit, try to select value instead.\n        e.preventDefault();\n        e.stopPropagation();\n        this.selectItemIfNoneSelected();\n        this.input.blur();\n      }\n    } else if (e.keyCode === KEY_CODE_TAB) {\n      this.selectItemIfNoneSelected();\n      this.input.blur();\n    } else if (e.keyCode === KEY_CODE_ESC && this.input) {\n      this.input.blur();\n    }\n  }\n\n  // Handle input text change, fetch predictions if the value isn't empty\n  onChange(e) {\n    const onChange = this.props.input.onChange;\n    const predictions = this.currentPredictions();\n    const newValue = e.target.value;\n\n    // Clear the current values since the input content is changed\n    onChange({\n      search: newValue,\n      predictions: newValue ? predictions : [],\n      selectedPlace: null,\n    });\n\n    // Clear highlighted prediction since the input value changed and\n    // results will change as well\n    this.setState({ highlightedIndex: -1 });\n\n    if (!newValue) {\n      // No need to fetch predictions on empty input\n      return;\n    }\n\n    if (newValue.length >= 3) {\n      if (this.shortQueryTimeout) {\n        window.clearTimeout(this.shortQueryTimeout);\n      }\n      this.predict(newValue);\n    } else {\n      this.shortQueryTimeout = window.setTimeout(() => {\n        this.predict(newValue);\n      }, DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES);\n    }\n  }\n\n  // Change the currently highlighted item by calculating the new\n  // index from the current state and the given direction number\n  // (DIRECTION_UP or DIRECTION_DOWN)\n  changeHighlight(direction) {\n    this.setState((prevState, props) => {\n      const predictions = this.currentPredictions();\n      const currentIndex = prevState.highlightedIndex;\n      let index = currentIndex;\n\n      if (direction === DIRECTION_UP) {\n        // Keep the first position if already highlighted\n        index = currentIndex === 0 ? 0 : currentIndex - 1;\n      } else if (direction === DIRECTION_DOWN) {\n        index = currentIndex + 1;\n      }\n\n      // Check that the index is within the bounds\n      if (index < 0) {\n        index = -1;\n      } else if (index >= predictions.length) {\n        index = predictions.length - 1;\n      }\n\n      return { highlightedIndex: index };\n    });\n  }\n\n  // Select the prediction in the given item. This will fetch/read the\n  // place details and set it as the selected place.\n  selectPrediction(prediction) {\n    this.props.input.onChange({\n      ...this.props.input,\n      selectedPlace: null,\n    });\n\n    this.setState({ fetchingPlaceDetails: true });\n\n    this.getGeocoder()\n      .getPlaceDetails(prediction)\n      .then(place => {\n        if (!this._isMounted) {\n          // Ignore if component already unmounted\n          return;\n        }\n        this.setState({ fetchingPlaceDetails: false });\n        this.props.input.onChange({\n          search: place.address,\n          predictions: [],\n          selectedPlace: place,\n        });\n      })\n      .catch(e => {\n        this.setState({ fetchingPlaceDetails: false });\n        // eslint-disable-next-line no-console\n        console.error(e);\n        this.props.input.onChange({\n          ...this.props.input.value,\n          selectedPlace: null,\n        });\n      });\n  }\n  selectItemIfNoneSelected() {\n    if (this.state.fetchingPredictions) {\n      // No need to select anything since prediction fetch is still going on\n      return;\n    }\n\n    const { search, selectedPlace } = currentValue(this.props);\n    const predictions = this.currentPredictions();\n    if (!selectedPlace) {\n      if (predictions && predictions.length > 0) {\n        const index = this.state.highlightedIndex !== -1 ? this.state.highlightedIndex : 0;\n        this.selectPrediction(predictions[index]);\n      } else {\n        this.predict(search);\n      }\n    }\n  }\n  predict(search) {\n    const onChange = this.props.input.onChange;\n    this.setState({ fetchingPredictions: true });\n\n    return this.getGeocoder()\n      .getPlacePredictions(search)\n      .then(results => {\n        const { search: currentSearch } = currentValue(this.props);\n        this.setState({ fetchingPredictions: false });\n\n        // If the earlier predictions arrive when the user has already\n        // changed the search term, ignore and wait until the latest\n        // predictions arrive. Without this logic, results for earlier\n        // requests would override whatever the user had typed since.\n        //\n        // This is essentially the same as switchLatest in RxJS or\n        // takeLatest in Redux Saga, without canceling the earlier\n        // requests.\n        if (results.search === currentSearch) {\n          onChange({\n            search: results.search,\n            predictions: results.predictions,\n            selectedPlace: null,\n          });\n        }\n      })\n      .catch(e => {\n        this.setState({ fetchingPredictions: false });\n        // eslint-disable-next-line no-console\n        console.error(e);\n        const value = currentValue(this.props);\n        onChange({\n          ...value,\n          selectedPlace: null,\n        });\n      });\n  }\n\n  finalizeSelection() {\n    this.setState({ inputHasFocus: false, highlightedIndex: -1 });\n    this.props.input.onBlur(currentValue(this.props));\n  }\n\n  handleOnBlur() {\n    if (this.props.closeOnBlur && !this.state.selectionInProgress) {\n      this.finalizeSelection();\n    }\n  }\n\n  handlePredictionsSelectStart(touchCoordinates) {\n    this.setState({\n      selectionInProgress: true,\n      touchStartedFrom: touchCoordinates,\n      isSwipe: false,\n    });\n  }\n\n  handlePredictionsSelectMove(touchCoordinates) {\n    this.setState(prevState => {\n      const touchStartedFrom = prevState.touchStartedFrom;\n      const isTouchAction = !!touchStartedFrom;\n      const isSwipe = isTouchAction\n        ? Math.abs(touchStartedFrom.y - touchCoordinates.y) > TOUCH_TAP_RADIUS\n        : false;\n\n      return { selectionInProgress: false, isSwipe };\n    });\n  }\n\n  handlePredictionsSelectEnd(prediction) {\n    let selectAndFinalize = false;\n    this.setState(\n      prevState => {\n        if (!prevState.isSwipe) {\n          selectAndFinalize = true;\n        }\n        return { selectionInProgress: false, touchStartedFrom: null, isSwipe: false };\n      },\n      () => {\n        if (selectAndFinalize) {\n          this.selectPrediction(prediction);\n          this.finalizeSelection();\n        }\n      }\n    );\n  }\n\n  render() {\n    const {\n      autoFocus,\n      rootClassName,\n      className,\n      iconClassName,\n      inputClassName,\n      predictionsClassName,\n      predictionsAttributionClassName,\n      validClassName,\n      placeholder,\n      input,\n      meta,\n      inputRef,\n    } = this.props;\n    const { name, onFocus } = input;\n    const { search } = currentValue(this.props);\n    const { touched, valid } = meta || {};\n    const isValid = valid && touched;\n    const predictions = this.currentPredictions();\n\n    const handleOnFocus = e => {\n      this.setState({ inputHasFocus: true });\n      onFocus(e);\n    };\n\n    const rootClass = classNames(rootClassName || css.root, className);\n    const iconClass = classNames(iconClassName || css.icon);\n    const inputClass = classNames(inputClassName || css.input, { [validClassName]: isValid });\n    const predictionsClass = classNames(predictionsClassName);\n\n    // Only render predictions when the input has focus. For\n    // development and easier workflow with the browser devtools, you\n    // might want to hardcode this to `true`. Otherwise the dropdown\n    // list will disappear.\n    const renderPredictions = this.state.inputHasFocus;\n\n    return (\n      <div className={rootClass}>\n        <div className={iconClass}>\n          {this.state.fetchingPlaceDetails ? (\n            <IconSpinner className={css.iconSpinner} />\n          ) : (\n            <IconHourGlass />\n          )}\n        </div>\n        <input\n          className={inputClass}\n          type=\"search\"\n          autoComplete=\"off\"\n          autoFocus={autoFocus}\n          placeholder={placeholder}\n          name={name}\n          value={search}\n          disabled={this.state.fetchingPlaceDetails}\n          onFocus={handleOnFocus}\n          onBlur={this.handleOnBlur}\n          onChange={this.onChange}\n          onKeyDown={this.onKeyDown}\n          ref={node => {\n            this.input = node;\n            if (inputRef) {\n              inputRef(node);\n            }\n          }}\n        />\n        {renderPredictions ? (\n          <LocationPredictionsList\n            rootClassName={predictionsClass}\n            attributionClassName={predictionsAttributionClassName}\n            predictions={predictions}\n            geocoder={this.getGeocoder()}\n            highlightedIndex={this.state.highlightedIndex}\n            onSelectStart={this.handlePredictionsSelectStart}\n            onSelectMove={this.handlePredictionsSelectMove}\n            onSelectEnd={this.handlePredictionsSelectEnd}\n          />\n        ) : null}\n      </div>\n    );\n  }\n}\n\nLocationAutocompleteInputImpl.defaultProps = {\n  autoFocus: false,\n  closeOnBlur: true,\n  rootClassName: null,\n  className: null,\n  iconClassName: null,\n  inputClassName: null,\n  predictionsClassName: null,\n  predictionsAttributionClassName: null,\n  validClassName: null,\n  placeholder: '',\n  useDefaultPredictions: true,\n  meta: null,\n  inputRef: null,\n};\n\nLocationAutocompleteInputImpl.propTypes = {\n  autoFocus: bool,\n  rootClassName: string,\n  className: string,\n  closeOnBlur: bool,\n  iconClassName: string,\n  inputClassName: string,\n  predictionsClassName: string,\n  predictionsAttributionClassName: string,\n  validClassName: string,\n  placeholder: string,\n  useDefaultPredictions: bool,\n  input: shape({\n    name: string.isRequired,\n    value: oneOfType([\n      shape({\n        search: string,\n        predictions: any,\n        selectedPlace: propTypes.place,\n      }),\n      string,\n    ]),\n    onChange: func.isRequired,\n    onFocus: func.isRequired,\n    onBlur: func.isRequired,\n  }).isRequired,\n  meta: shape({\n    valid: bool.isRequired,\n    touched: bool.isRequired,\n  }),\n  inputRef: func,\n};\n\nexport default LocationAutocompleteInputImpl;\n"]},"metadata":{},"sourceType":"module"}