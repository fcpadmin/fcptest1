{"ast":null,"code":"/**\n * CheckoutPage starts payment process and therefore it will get data from ListingPage\n * (booking dates, listing data, and all the other data that affects to booking decision).\n * This data is saved to Session Store which only exists while the browsing session exists -\n * e.g. tab is open. (Session Store is not related to session cookies.)\n */\nimport moment from 'moment';\nimport reduce from 'lodash/reduce';\nimport { types as sdkTypes } from '../../util/sdkLoader';\nimport { TRANSITION_ENQUIRE } from '../../util/transaction';\nconst UUID = sdkTypes.UUID,\n      Money = sdkTypes.Money; // Validate that given 'obj' has all the keys of defined by validPropTypes parameter\n// and values must pass related test-value-format function.\n\nconst validateProperties = (obj, validPropTypes) => {\n  return reduce(Object.entries(validPropTypes), (acc, [prop, fn]) => {\n    if (Object.prototype.hasOwnProperty.call(obj, prop) && fn(obj[prop])) {\n      return acc;\n    }\n\n    return false;\n  }, true);\n}; // Validate content of booking dates object received from SessionStore\n\n\nexport const isValidBookingDates = bookingDates => {\n  const props = {\n    bookingStart: d => d instanceof Date,\n    bookingEnd: d => d instanceof Date\n  };\n  return validateProperties(bookingDates, props);\n}; // Validate content of listing object received from SessionStore.\n// Currently only id & attributes.price are needed.\n\nexport const isValidListing = listing => {\n  const props = {\n    id: id => id instanceof UUID,\n    attributes: v => {\n      return typeof v === 'object' && v.price instanceof Money;\n    }\n  };\n  return validateProperties(listing, props);\n}; // Validate content of an enquired transaction received from SessionStore.\n// An id is required and the last transition needs to be the enquire transition.\n\nexport const isValidEnquiredTransaction = transaction => {\n  const props = {\n    id: id => id instanceof UUID,\n    attributes: v => {\n      return typeof v === 'object' && v.lastTransition === TRANSITION_ENQUIRE;\n    }\n  };\n  return validateProperties(transaction, props);\n}; // Stores given bookingDates and listing to sessionStorage\n\nexport const storeData = (bookingData, bookingDates, listing, enquiredTransaction, storageKey) => {\n  if (window && window.sessionStorage && listing && bookingDates && bookingData) {\n    // TODO: How should we deal with Dates when data is serialized?\n    // Hard coded serializable date objects atm.\n\n    /* eslint-disable no-underscore-dangle */\n    const data = {\n      bookingData,\n      bookingDates: {\n        bookingStart: {\n          date: bookingDates.bookingStart,\n          _serializedType: 'SerializableDate'\n        },\n        bookingEnd: {\n          date: bookingDates.bookingEnd,\n          _serializedType: 'SerializableDate'\n        }\n      },\n      listing,\n      enquiredTransaction,\n      storedAt: {\n        date: new Date(),\n        _serializedType: 'SerializableDate'\n      }\n    };\n    /* eslint-enable no-underscore-dangle */\n\n    const storableData = JSON.stringify(data, sdkTypes.replacer);\n    window.sessionStorage.setItem(storageKey, storableData);\n  }\n}; // Get stored data\n\nexport const storedData = storageKey => {\n  if (window && window.sessionStorage) {\n    const checkoutPageData = window.sessionStorage.getItem(storageKey); // TODO How should we deal with Dates when data is serialized?\n    // Dates are expected to be in format: { date: new Date(), _serializedType: 'SerializableDate' }\n\n    const reviver = (k, v) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (v && typeof v === 'object' && v._serializedType === 'SerializableDate') {\n        return new Date(v.date);\n      }\n\n      return sdkTypes.reviver(k, v);\n    };\n\n    const _ref = checkoutPageData ? JSON.parse(checkoutPageData, reviver) : {},\n          bookingData = _ref.bookingData,\n          bookingDates = _ref.bookingDates,\n          listing = _ref.listing,\n          enquiredTransaction = _ref.enquiredTransaction,\n          storedAt = _ref.storedAt; // If sessionStore contains freshly saved data (max 1 day old), use it\n\n\n    const isFreshlySaved = storedAt ? moment(storedAt).isAfter(moment().subtract(1, 'days')) : false; // resolve enquired transaction as valid if it is missing\n\n    const isEnquiredTransactionValid = !!enquiredTransaction ? isValidEnquiredTransaction(enquiredTransaction) : true;\n    const isStoredDataValid = isFreshlySaved && isValidBookingDates(bookingDates) && isValidListing(listing) && isEnquiredTransactionValid;\n\n    if (isStoredDataValid) {\n      return {\n        bookingData,\n        bookingDates,\n        listing,\n        enquiredTransaction\n      };\n    }\n  }\n\n  return {};\n};\nexport const clearData = storageKey => {\n  if (window && window.sessionStorage) {\n    window.sessionStorage.removeItem(storageKey);\n  }\n};","map":{"version":3,"sources":["/Users/matthewmcelwee/fcprepos/webtest1/flex-template-web/src/containers/CheckoutPage/CheckoutPageSessionHelpers.js"],"names":["moment","reduce","types","sdkTypes","TRANSITION_ENQUIRE","UUID","Money","validateProperties","obj","validPropTypes","Object","entries","acc","prop","fn","prototype","hasOwnProperty","call","isValidBookingDates","bookingDates","props","bookingStart","d","Date","bookingEnd","isValidListing","listing","id","attributes","v","price","isValidEnquiredTransaction","transaction","lastTransition","storeData","bookingData","enquiredTransaction","storageKey","window","sessionStorage","data","date","_serializedType","storedAt","storableData","JSON","stringify","replacer","setItem","storedData","checkoutPageData","getItem","reviver","k","parse","isFreshlySaved","isAfter","subtract","isEnquiredTransactionValid","isStoredDataValid","clearData","removeItem"],"mappings":"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","sourcesContent":["/**\n * CheckoutPage starts payment process and therefore it will get data from ListingPage\n * (booking dates, listing data, and all the other data that affects to booking decision).\n * This data is saved to Session Store which only exists while the browsing session exists -\n * e.g. tab is open. (Session Store is not related to session cookies.)\n */\nimport moment from 'moment';\nimport reduce from 'lodash/reduce';\nimport { types as sdkTypes } from '../../util/sdkLoader';\nimport { TRANSITION_ENQUIRE } from '../../util/transaction';\n\nconst { UUID, Money } = sdkTypes;\n\n// Validate that given 'obj' has all the keys of defined by validPropTypes parameter\n// and values must pass related test-value-format function.\nconst validateProperties = (obj, validPropTypes) => {\n  return reduce(\n    Object.entries(validPropTypes),\n    (acc, [prop, fn]) => {\n      if (Object.prototype.hasOwnProperty.call(obj, prop) && fn(obj[prop])) {\n        return acc;\n      }\n      return false;\n    },\n    true\n  );\n};\n\n// Validate content of booking dates object received from SessionStore\nexport const isValidBookingDates = bookingDates => {\n  const props = {\n    bookingStart: d => d instanceof Date,\n    bookingEnd: d => d instanceof Date,\n  };\n  return validateProperties(bookingDates, props);\n};\n\n// Validate content of listing object received from SessionStore.\n// Currently only id & attributes.price are needed.\nexport const isValidListing = listing => {\n  const props = {\n    id: id => id instanceof UUID,\n    attributes: v => {\n      return typeof v === 'object' && v.price instanceof Money;\n    },\n  };\n  return validateProperties(listing, props);\n};\n\n// Validate content of an enquired transaction received from SessionStore.\n// An id is required and the last transition needs to be the enquire transition.\nexport const isValidEnquiredTransaction = transaction => {\n  const props = {\n    id: id => id instanceof UUID,\n    attributes: v => {\n      return typeof v === 'object' && v.lastTransition === TRANSITION_ENQUIRE;\n    },\n  };\n  return validateProperties(transaction, props);\n};\n\n// Stores given bookingDates and listing to sessionStorage\nexport const storeData = (bookingData, bookingDates, listing, enquiredTransaction, storageKey) => {\n  if (window && window.sessionStorage && listing && bookingDates && bookingData) {\n    // TODO: How should we deal with Dates when data is serialized?\n    // Hard coded serializable date objects atm.\n    /* eslint-disable no-underscore-dangle */\n    const data = {\n      bookingData,\n      bookingDates: {\n        bookingStart: { date: bookingDates.bookingStart, _serializedType: 'SerializableDate' },\n        bookingEnd: { date: bookingDates.bookingEnd, _serializedType: 'SerializableDate' },\n      },\n      listing,\n      enquiredTransaction,\n      storedAt: { date: new Date(), _serializedType: 'SerializableDate' },\n    };\n    /* eslint-enable no-underscore-dangle */\n\n    const storableData = JSON.stringify(data, sdkTypes.replacer);\n    window.sessionStorage.setItem(storageKey, storableData);\n  }\n};\n\n// Get stored data\nexport const storedData = storageKey => {\n  if (window && window.sessionStorage) {\n    const checkoutPageData = window.sessionStorage.getItem(storageKey);\n\n    // TODO How should we deal with Dates when data is serialized?\n    // Dates are expected to be in format: { date: new Date(), _serializedType: 'SerializableDate' }\n    const reviver = (k, v) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (v && typeof v === 'object' && v._serializedType === 'SerializableDate') {\n        return new Date(v.date);\n      }\n      return sdkTypes.reviver(k, v);\n    };\n\n    const { bookingData, bookingDates, listing, enquiredTransaction, storedAt } = checkoutPageData\n      ? JSON.parse(checkoutPageData, reviver)\n      : {};\n\n    // If sessionStore contains freshly saved data (max 1 day old), use it\n    const isFreshlySaved = storedAt\n      ? moment(storedAt).isAfter(moment().subtract(1, 'days'))\n      : false;\n\n    // resolve enquired transaction as valid if it is missing\n    const isEnquiredTransactionValid = !!enquiredTransaction\n      ? isValidEnquiredTransaction(enquiredTransaction)\n      : true;\n\n    const isStoredDataValid =\n      isFreshlySaved &&\n      isValidBookingDates(bookingDates) &&\n      isValidListing(listing) &&\n      isEnquiredTransactionValid;\n\n    if (isStoredDataValid) {\n      return { bookingData, bookingDates, listing, enquiredTransaction };\n    }\n  }\n  return {};\n};\n\nexport const clearData = storageKey => {\n  if (window && window.sessionStorage) {\n    window.sessionStorage.removeItem(storageKey);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}